
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>不可卷也</title>
  <meta name="author" content="njuxjy">

  
  <meta name="description" content="项目中的会话界面逻辑很复杂，滚动起来有些卡。从发现问题到一步步解决，过程如下： 锁定问题就和tableview的几个代理函数有关。于是基于二分法的思想，注释掉部分代码，检查只运行其余代码会不会卡。
这样找下来发现性能瓶颈在设置用户头像的函数。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xiaojiayi.com/blog/page/5">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="不可卷也" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">不可卷也</a></h1>
  
    <h2>njuxjy's blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:xiaojiayi.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/01/e8aeb0e4b880e6aca1tableviewe6bb9ae58aa8e680a7e883bde8b083e4bc98/">记一次tableview滚动性能调优</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-01T22:33:47+08:00" pubdate data-updated="true">Mar 1<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>项目中的会话界面逻辑很复杂，滚动起来有些卡。从发现问题到一步步解决，过程如下：</p>

<ol>
<li><p>锁定问题就和tableview的几个代理函数有关。于是基于二分法的思想，注释掉部分代码，检查只运行其余代码会不会卡。</p></li>
<li><p>这样找下来发现性能瓶颈在设置用户头像的函数。 是之前项目里已有的一个UIButton的网络图片下载分类，里面会对图片路径进行MD5的加密，并且没用内存缓存，每次都从磁盘将头像读入UIImage，而头像照片的尺寸有的很大，于是把头像下载控件换成开源的SDWebImage，原以为就能圆满解决，结果发现还是有问题。</p></li>
<li><p>只能靠工具了。用了Profile工具查CPU发现是每个cell在计算是否需要加上消息显示日期的时候，日期部分的计算占了大量cpu。每个cell的绘制都频繁创建和销毁NSCalendar和NSDateTimeFormatterz对象，而这两个对象的创建是比较昂贵的，难怪会卡。于是将NSCalendar和NSDateTimeFormatter改为全局cache，不需要每次都创建，粗略测了下发现不卡了。</p></li>
<li><p>过了阵子又去测测发现又开始卡了（肯定遇到了未覆盖到的测试用例）。 肯定还有其他地方性能不够好。。 再接再厉，再次运行profile工具，多滚动列表一会，然后观察时间最长的部分在哪里。发现NSDateFormatter的dateFromString函数和获取登录用户头像路径的函数都比较耗时，于是采取逐个击破的方式，先注释掉其中一个的代码，调试另一个。首先将耗时的计算结果尽可能的缓存，比如这里的获取登录用户头像路径。改好后还是卡，说明dateFromString函数的计算时间需要减少，但这是系统函数（我还一度以为是该函数的性能有问题，去SO上搜索半天没人反映它有什么问题）。于是就假设是该函数调用次数太多了。</p></li>
</ol>


<p>5. 经检查发现在计算cell高度和绘制cell时，为了确定是否要显示时间条，需要计算两个时间之差是否在五分钟内，计算的函数都要调用dateFromString。必须把计算移到外面去，把结果保存好。改完后好了一阵，多测测又不行了。。还是有丢帧的感觉。。后来怀疑是debug模式下log没关，因为据说每一句NSLog底层都会调用[NSCalendar currentCalendar]，但关了以后发现还是不行。有些束手无策。</p>

<p>6.  然后发现整个会话中没有时间条的时候都很顺畅，有了几个时间条以后滚动就会有点卡，于是目光聚焦在绘制时间条的地方。由于之前对时间条UILabel的layer使用了圆角设置了borderColor，这个肯定很耗时，去掉，用默认的UILabel格式，然后在draw的时候根据是否需要展示时间条来设置其hidden属性。发现还是卡。然后发现把UILabel的颜色改成clearColor（跟tableView的backgroundColor一样）就不卡了。之前网上看到说clearColor会影响性能，但这里竟然好像改善了性能。原因可能是在tableView背景色透明时，在上面画不同色的view比较耗时。 然后在label后面加了个背景图，就解决了原先需要用layer的问题了。最终问题解决。当然肯定还有优化空间，但至少比较流畅了，就不做“过早优化”了。</p>

<p>总结下：</p>

<ol>
<li><p>Time Profile很重要，光凭感觉去猜是不靠谱的。这一点WWDC里也提到了。</p></li>
<li><p>性能问题有可能由单个大问题引起，也可能由很多小问题叠加引起。对于后者，用“控制变量法”逐个击破。</p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/02/27/e7b1bbe5beaee4bfa1e59091e4b88ae6bb91e58aa8e58f96e6b688e58f91e98081e99fb3e9a291e79a84e5ae9ee78eb0/">类微信向上滑动取消发送音频的实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-27T14:38:54+08:00" pubdate data-updated="true">Feb 27<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>之前在项目中实现了音频对讲功能，现在要加上类似微信最新版的向上滑动取消发送功能，看似很简单，也花了些功夫。有更方便的实现欢迎交流。</p>

<p><img src="/images/2013/02/1.png"></p>

<p>界面如上所示。底部是一个UIView的子类ChatVoiceView，“按住说话”按钮是该view上的子view。现在要实现的效果是长按该按钮时，向上滑动时画面中央出现“松开手指取消发送”的提示，向下滑动时出现其他提示，同时一直在录着音。手势的滑动可以发生在该界面的任何部分，在上面的tableview伤滑动也有效。</p>

<p>在ChatVoiceView中首先给按钮加上一些事件关联：</p>

<pre><code>    [self.longPressBtn addTarget:self action:@selector(voiceHoldButtonTouchUpInside:withEvent:) forControlEvents:UIControlEventTouchUpInside];
    [self.longPressBtn addTarget:self action:@selector(voiceHoldButtonTouchUpOutside:withEvent:) forControlEvents:UIControlEventTouchUpOutside];
    [self.longPressBtn addTarget:self action:@selector(voiceHoldButtonDragOutside:withEvent:) forControlEvents:UIControlEventTouchDragOutside];
</code></pre>

<p>在响应函数中，除了录音相关的操作外，将事件传递给按钮的nextResponder，也就是让ChatVoiceView根据按钮被按下去的状态做不同的处理：</p>

<pre><code>- (void)voiceHoldButtonDragOutside:(id)sender withEvent:(UIEvent *)event
{
    self.longPressBtn.highlighted = YES;
    shouldResponseToSwipe = YES;
    [[sender nextResponder] touchesMoved:[event allTouches] withEvent:event];
}

- (void)voiceHoldButtonTouchUpInside:(id)sender withEvent:(UIEvent *)event
{
    shouldResponseToSwipe = YES;
    //do sth here
    [[sender nextResponder] touchesEnded:[event allTouches] withEvent:event];
}

- (void)voiceHoldButtonTouchUpOutside:(id)sender withEvent:(UIEvent *)event
{
    shouldResponseToSwipe = YES;
    //do sth here
    [[sender nextResponder] touchesEnded:[event allTouches] withEvent:event];
}
</code></pre>

<p>在ChatVoiceView中加上触摸事件捕获函数：</p>

<pre><code>- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
    if(shouldResponseToSwipe == NO)
    {
        return;
    }
    UITouch *touch = [touches anyObject];
    CGPoint location = [touch locationInView:self.superview];
    CGPoint prevLocation = [touch previousLocationInView:self.superview];
    if (location.y - prevLocation.y &gt; 0 &amp;&amp; direction == 1)//向下
    {
        //do sth
    }
    else if(location.y - prevLocation.y &lt; 0 &amp;&amp; direction == 2)//向上
    {
        //do sth
    }
}
-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
    if(shouldResponseToSwipe == NO)
    {
        return;
    }
    shouldResponseToSwipe = NO;
}
</code></pre>

<p>done.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/12/iose5ad97e4bd93/">iOS字体</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-12T14:57:44+08:00" pubdate data-updated="true">Dec 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>可以参考：<a href="http://iosfonts.com">http://iosfonts.com</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/03/e58ebbe999a4grouped-uitableviewe79a84e8beb9e6a186e4b88ee8838ce699af/">去除Grouped UITableView的边框与背景</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-03T17:19:46+08:00" pubdate data-updated="true">Dec 3<span>rd</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>viewDidLoad中，</p>

<p>self.tableView.backgroundView = nil; //去除table背景</p>

<p>[self.tableView setSeparatorColor:[UIColor clearColor]]; //去除边框</p>

<p>cell创建过程中，</p>

<p>[cell setBackgroundColor:[UIColor clearColor]];  //去除背景</p>

<p>然后就可以根据cell的位置是top、middle、bottom和single来贴不同的自定义背景图了。</p>

<p>ps: 如果只要去掉某个cell的背景和边框，可以对某个cell调用：</p>

<pre><code>&lt;code&gt;cell.backgroundView = [[[UIView alloc] initWithFrame:CGRectZero] autorelease];&lt;/code&gt;
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/11/07/cfurlcreatewithstringe59ca8e6a8a1e68b9fe599a8e4b88ae8bf94e59b9enulle79a84e997aee9a298/">CFURLCreateWithString在模拟器上返回null的问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-11-07T12:50:45+08:00" pubdate data-updated="true">Nov 7<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在程序中用到了</p>

<p>CFURLRef  url = CFURLCreateWithString(kCFAllocatorDefault, (CFStringRef)fileName, NULL);</p>

<p>其中fileName的值是应用目录下的某个文件，在真机上一切正常，但在模拟器上url始终为Null。</p>

<p>最后查出是因为fileName的值在模拟器上是“~/Library/Application Support/iPhone Simulator/&hellip;/”，路径中间有空格，而真机上没有，所以要对fileName中的空格进行处理：</p>

<p>CFStringRef fileNameEscaped = CFURLCreateStringByAddingPercentEscapes(NULL, (CFStringRef)fileName, NULL, NULL, kCFStringEncodingUTF8);</p>

<p>这下就对了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/31/iose69187e58aa8e6a380e6b58b/">iOS摇动检测</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-31T10:51:38+08:00" pubdate data-updated="true">Oct 31<span>st</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先在AppDelegate中开启摇动支持：</p>

<p>安师大</p>

<pre><code>- (void)applicationDidFinishLaunching:(UIApplication *)application {
        application.applicationSupportsShakeToEdit = YES;
        [window addSubview:viewController.view];
        [window makeKeyAndVisible];
}
</code></pre>

<p>首先在AppDelegate中开启摇动支持：ViewController中增加三个方法：canbecomeFirstResponder:, viewDidAppear:和viewWillDisappear:。</p>

<pre><code>-(BOOL)canBecomeFirstResponder {
    return YES;
}

-(void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    [self becomeFirstResponder];
}

- (void)viewWillDisappear:(BOOL)animated {
    [self resignFirstResponder];
    [super viewWillDisappear:animated];
}
</code></pre>

<p>增加motionEnded方法:</p>

<pre><code>- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event
{
    if (motion == UIEventSubtypeMotionShake)
    {
        // your code
    }
}
</code></pre>

<p>ok, that&rsquo;s it.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/12/e4bba3e7a081e68892e5be8befbc9aobjective-ce69c80e4bdb3e5ae9ee8b7b5efbc88e8af91e69687efbc89/">代码戒律：Objective-C最佳实践（译文）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-12T10:57:00+08:00" pubdate data-updated="true">Oct 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在逛V2EX时候发现了这篇文章，遂决定翻译一下，自己也顺带学习下。</p>

<p>作者的一些观点有些偏激，自己心里有数就好。</p>

<p>原文网址：<a href="http://ironwolf.dangerousgames.com/blog/archives/913">http://ironwolf.dangerousgames.com/blog/archives/913</a></p>

<p>=========================</p>

<h3>2012.4.26更新，加入了ARC</h3>

<h2>前言</h2>

<p>我通常在自己的博客中不会写太技术性的东西，但这次例外，因为我希望为Mac和iOS（iPhone&amp;iPad）开发者社区做些贡献。如果你不是社区中的一员，请自行绕道吧。</p>

<h2>介绍</h2>

<p> 这篇文章是在我多年的Objective-C使用经验中所目睹的那些最容易被Objective-C程序员触犯的最佳实践积累下来的一个列表。我称之为“戒律”，我们有太多理由要去遵守它们，几乎没理由不去遵守。然而当我向其他开发者展示这些实践经验时，他们往往非常反对&hellip;</p>

<h2>强烈反对：这不会影响性能吗？</h2>

<p>这个反对基本没什么道理。如果你能向我举出一个例子来证明遵循以下任何一条规范写出来的代码<strong>竟然</strong>成了性能瓶颈，那我祝愿你能不按照规范优化出好的代码，只要你能够<strong>在代码中清楚地写明</strong>你是<strong>怎样</strong>打破规范的以及<strong>为什么</strong>。</p>

<h2>为什么？</h2>

<p>这些规范为了让代码更安全，节省内存，提高可读性和可维护性。大多数规范<strong>不能</strong>帮助提高性能。然而，写代码时不应该首先考虑性能。我们应该写出简洁、正确的代码，仅仅当性能分析告诉你有必要优化时才去做优化。在典型的UI驱动应用中，最大的瓶颈在于用户，然后是网络访问，接着是磁盘访问。但是，过早优化在程序员中还是非常普遍，他们认为如果他们不用尽所有手段去优化的话，他们的应用将会慢的跟狗一样。这肯定是不对的。</p>

<h2>重要建议</h2>

<p>即使在你写的时候知道你的代码是如何工作的，那也不意味着其他人在尝试修改你的代码前会真正理解它，也不意味着你在几个月后再次看这段代码时能理解它。使用详细的符号命名（译者注：即变量和方法名等用详细的词来命名），在仍然不够易于理解的代码段中加入详细的注释，这样就能<strong>总是</strong>确保你的代码能够自说明（译者注：self-documenting，即代码易于理解，不需要写文档也能让人读懂它）。每当你解bug或者API误用的时候，将你认为可能会出问题的地方定位在某个方法里，解释这个方法，然后在注释中加入类似<a href="http://en.wikipedia.org/wiki/KLUDGE">KLUDGE</a>的关键字，之后你就能轻易的发现并且解决这些问题了。</p>

<h2>文章（尚）未涉及的内容</h2>

<ul>
<li>键值编码(KVC)和基于键值的观察者(KVO)。你有可能会用到它们。</li>
</ul>


<h3>2012.4.26新增</h3>

<h3>戒律&hellip;</h3>

<p><strong>总是</strong>使用自动引用技术(ARC)。这篇文章已经移除了非ARC代码风格。所有的新代码应当用ARC来写，所有的遗留代码应当更新为ARC(或者封装完备并给出精妙的接口)。</p>

<h3>戒律&hellip;</h3>

<p><strong>总是</strong>在任何实例变量的声明前加上@private指令，<strong>永远不要</strong>在类外面直接访问实例变量。</p>

<h3>为什么？</h3>

<ul>
<li><p>将信息隐藏(封装)</p></li>
<li><p>只在类实现的方法中才去直接访问实例变量</p></li>
<li><p>实例变量的默认访问属性是@protected，意味着子类可以自由访问这些实例变量。但没有足够的理由不要允许子类这么做——父类暴露给外界的所有东西是它的一种契约，改变类成员的内部表示而不改变它的接口或者契约是面向对象封装的重要好处。将你的实例变量设为私有，你就告诉外界它们是实现的细节而非类的接口</p></li>
</ul>


<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a> {</p>

<ol>
<li></li>
</ol>


<p>        int a;</p>

<ol>
<li></li>
</ol>


<p>        <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* b;</p>

<ol>
<li></li>
</ol>


<p>        // …</p>

<ol>
<li></li>
</ol>


<p>}</p>

<ol>
<li></li>
</ol>


<p>// method &amp; property declarations…</p>

<ol>
<li></li>
</ol>


<p>@end</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a> {</p>

<ol>
<li></li>
</ol>


<p>        @private</p>

<ol>
<li></li>
</ol>


<p>        int a;</p>

<ol>
<li></li>
</ol>


<p>        <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* b;</p>

<ol>
<li></li>
</ol>


<p>        // …</p>

<ol>
<li></li>
</ol>


<p>}</p>

<ol>
<li></li>
</ol>


<p>// method &amp; property declarations…</p>

<ol>
<li> @end</li>
</ol>


<h3>戒律…</h3>

<p>总是为每个数据成员创建@property，然后在类实现中用&#8221;self.name&#8221;去访问它。永远不要直接访问你的实例变量。</p>

<h3>为什么?</h3>

<ul>
<li><p>属性强制加上了访问限制(例如readonly)</p></li>
<li><p>属性强制加上了内存管理策略(strong,weak)</p></li>
<li><p>属性帮你实现了setter和getter</p></li>
<li><p>使用属性可以强制执行线程安全策略</p></li>
<li><p>单一的访问实例变量的方法可以增加代码可读性</p></li>
</ul>


<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a> {</p>

<ol>
<li></li>
</ol>


<p>        @private</p>

<ol>
<li></li>
</ol>


<p>        <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
</ol>


<p>}</p>

<ol>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li></li>
</ol>


<p>- (void)bar {</p>

<ol>
<li></li>
</ol>


<p>        myObj = nil;</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li>.</li>
</ol>


<p>@end</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a> {</p>

<ol>
<li></li>
</ol>


<p>        @private</p>

<ol>
<li></li>
</ol>


<p>        <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
</ol>


<p>}</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li><p>.</p></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li>.</li>
</ol>


<p>- (void)bar {</p>

<ol>
<li>.</li>
</ol>


<p>        self.myObj = nil;</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li>. @end</li>
</ol>


<h3>戒律…</h3>

<p><strong>总是</strong>在你的属性上加上&#8221;nonatomic&#8221;，除非你在写线程安全的类，确实需要原子访问，那就<strong>在代码中写注释表明你是故意这么做的</strong>。</p>

<h3>为什么?</h3>

<p>那些带有未声明为&#8221;nonatomic&#8221;属性的类会让人们觉得这是个设计成线程安全的类，但实际上并不是。只有在你确实将类设计成线程安全时，才不要在属性前加上&#8221;nonatomic&#8221;。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong) <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>// This class and all it’s properties are thread-safe.</p>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong) <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<h3>戒律…</h3>

<p><strong>永远不要</strong>让你的实例变量名字和属性名或者数据成员名有所混淆。<strong>总是</strong>在实例变量名结尾加上下划线。 除非你继承了第三方的类，这个类已经有一个数据成员有同样的名字，这样的话就选择一个不同的名字，或者再加一条下划线，然后<strong>加入注视解释你为什么要这么做</strong>。</p>

<p>在实现中使用&#8221;@synthesize name = name_;&ldquo;，而不要只写&rdquo;@synthesize name;&#8221;</p>

<h3>为什么?</h3>

<ul>
<li><p>即使是在类实现中你也最好属性访问器来访问数据成员，而不要直接访问，除非特殊情况。</p></li>
<li><p>苹果对于他们的私有实例变量用了&#8221;<em>name&#8221;的方式，那么你自己的就用&#8221;name</em>&ldquo;的方式好了，可以避免命名冲突。</p></li>
<li><p>苹果已经开始在那些应用级的代码示例及模板中使用&#8221;name_&ldquo;的命名习惯。</p></li>
</ul>


<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li></li>
</ol>


<p>// …</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@synthesize myObj;</p>

<ol>
<li><p>.</p></li>
<li><p>. @end</p></li>
</ol>


<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li></li>
</ol>


<p>// …</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@synthesize myObj = myObj_;</p>

<ol>
<li>.</li>
</ol>


<p> @end</p>

<h3>戒律…</h3>

<p><strong>NEVER</strong> redundantly add the data member to the class @interface yourself. Allow the @synthesize directive to implicitly add the data member.</p>

<p>Following this practice will yield many classes that explicitly declare no instance variables in the @interface section. When a class has no instance variables, omit the @private declaration, and even omit the opening and closing braces of the data member section.</p>

<p><strong>永远不要</strong>自己在类接口中重复增加数据成员。让@synthesize指令来为你隐式地增加数据成员。</p>

<p>遵从这条经验，许多类可以不用在类接口中显式地声明实例变量。当一个类没有实例变量时，可以省略@private声明，甚至连数据成员段的开闭括号都可以去掉。</p>

<h3>为什么?</h3>

<ul>
<li><p>减少重复。</p></li>
<li><p>简化类的头文件。</p></li>
<li><p>不需要把类的声明都写在公共头文件中，你可以在实现文件中声明那些真正会直接访问到的类成员。</p></li>
</ul>


<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a> {</p>

<ol>
<li></li>
</ol>


<p>        @private</p>

<ol>
<li></li>
</ol>


<p>        <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj_;</p>

<ol>
<li></li>
</ol>


<p>}</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li><p>.</p></li>
</ol>


<p>// …</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@synthesize myObj = myObj_;</p>

<ol>
<li><p>.</p></li>
<li><p>. @end</p></li>
</ol>


<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li></li>
</ol>


<p>// …</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@synthesize myObj = myObj_;</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@end</p>

<p>You may still need to declare the underlying name of the variable if you need to access it directly, as when writing custom getters and setters:</p>

<p>当你自己在为实例变量写setter和getter的时候，如果你在其中需要直接访问变量的话，你得声明名字带下划线的变量：</p>

<h3>错误的写法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li></li>
</ol>


<p>// …</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@synthesize myObj;</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>- (<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>*)myObj</p>

<ol>
<li>.</li>
</ol>


<p>{</p>

<ol>
<li>.</li>
</ol>


<p>        return self.myObj; // 会递归调用getter!</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>- (void)setMyObj:(<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>*)myObj</p>

<ol>
<li>.</li>
</ol>


<p>{</p>

<ol>
<li>.</li>
</ol>


<p>        self.myObj = myObj; // 会递归调用setter!</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>. @end</p></li>
</ol>


<h3>正确的写法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li></li>
</ol>


<p>// …</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@synthesize myObj = myObj_;</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>- (<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>*)myObj</p>

<ol>
<li>.</li>
</ol>


<p>{</p>

<ol>
<li>.</li>
</ol>


<p>        return myObj_; // 没问题.</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>- (void)setMyObj:(<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>*)myObj</p>

<ol>
<li>.</li>
</ol>


<p>{</p>

<ol>
<li>.</li>
</ol>


<p>        // 没问题</p>

<ol>
<li>.</li>
</ol>


<p>        myObj_ = myObj; // 进行赋值(ARC会处理必要的retain和release)</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>. @end</p></li>
</ol>


<h3>戒律…</h3>

<p><strong>NEVER</strong> access a data member through an underscore-suffixed symbol UNLESS you are writing a setter or getter.</p>

<p><strong>永远不要</strong>访问名字以下划线开头的变量，除非你在写setter或getter。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) Bar* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li></li>
</ol>


<p>// …</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@synthesize myObj = myObj_;</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>- (void)someMethod</p>

<ol>
<li>.</li>
</ol>


<p>{</p>

<ol>
<li>.</li>
</ol>


<p>        myObj_ = [[Bar alloc] init];</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>. @end</p></li>
</ol>


<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) Bar* myObj;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li></li>
</ol>


<p>// …</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@synthesize myObj = myObj_;</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>- (void)someMethod</p>

<ol>
<li>.</li>
</ol>


<p>{</p>

<ol>
<li>.</li>
</ol>


<p>        self.myObj = [[Bar alloc] init];</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>. @end</p></li>
</ol>


<h3>戒律…</h3>

<p><strong>永远不要</strong>在类的头文件中声明内部(私有)方法或属性。<strong>总是</strong>将所有的内部方法和属性声明放入实现文件中的“类扩展”中。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>//</p>

<ol>
<li></li>
</ol>


<p>// Foo.h</p>

<ol>
<li></li>
</ol>


<p>//</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(nonatomic) int myPublicProperty;</p>

<ol>
<li></li>
</ol>


<p>@property(strong, nonatomic) Bar* myPrivateProperty; // This can be accessed by anyone who includes the header</p>

<ol>
<li></li>
<li><p>.</p></li>
</ol>


<p>- (int)myPublicMethod;</p>

<ol>
<li>.</li>
</ol>


<p>- (int)myPrivateMethod; // So can this.</p>

<ol>
<li><p>.</p></li>
<li><p>. @end</p></li>
</ol>


<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>//</p>

<ol>
<li></li>
</ol>


<p>// Foo.h</p>

<ol>
<li></li>
</ol>


<p>//</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>// Only the public API can be accessed by including the header</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(nonatomic) int myPublicProperty;</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>- (int)myPublicMethod;</p>

<ol>
<li><p>.</p></li>
<li><p>. @end</p></li>
<li></li>
</ol>


<p>//</p>

<ol>
<li></li>
</ol>


<p>// Foo.m</p>

<ol>
<li></li>
</ol>


<p>//</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@interface Foo () // This is a &ldquo;class extension&rdquo; and everything declared in it is private, because it’s in the implementation file</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property(strong, nonatomic) Bar* myPrivateProperty;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (int)myPrivateMethod;</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@end</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li>.</li>
</ol>


<p>// …</p>

<ol>
<li>. @end</li>
</ol>


<h3>戒律…</h3>

<p><strong>永远不要</strong>在一个方法里有超过一句返回语句，让方法中的最后一个语句带有一个非空值的返回类型。</p>

<p>在返回非空值的方法中，第一句语句就声明一个变量保存返回值，给它一个有意义的默认值。必要时在代码不同路径中给它赋值。在最后一个语句中返回它的值。<strong>永远不要</strong>过早地用返回语句返回它的值。</p>

<h3>为什么?</h3>

<p>过早的返回语句会增加有一些必要资源释放没有被执行的可能性。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (Bar*)barWithInt:(int)n</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        // Allocate some resource here…</p>

<ol>
<li></li>
<li></li>
</ol>


<p>        if(n == 0) {</p>

<ol>
<li></li>
</ol>


<p>                // …and you have to deallocate the resource here…</p>

<ol>
<li></li>
</ol>


<p>                return [[Bar alloc] init];</p>

<ol>
<li>.</li>
</ol>


<p>        } else if(n == 1) {</p>

<ol>
<li>.</li>
</ol>


<p>                // …and here…</p>

<ol>
<li>.</li>
</ol>


<p>                return self.myBar;</p>

<ol>
<li>.</li>
</ol>


<p>        }</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>        // …and here.</p>

<ol>
<li>.</li>
</ol>


<p>        return nil;</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>. @end</p></li>
</ol>


<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (Bar*)barWithInt:(int)n</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        Bar* result = nil;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>        // Allocate some resource here…</p>

<ol>
<li></li>
<li></li>
</ol>


<p>        if(n == 0) {</p>

<ol>
<li>.</li>
</ol>


<p>                result = [[Bar alloc] init];</p>

<ol>
<li>.</li>
</ol>


<p>        } else if(n == 1) {</p>

<ol>
<li>.</li>
</ol>


<p>                result = self.myBar;</p>

<ol>
<li>.</li>
</ol>


<p>        }</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>        // …and deallocate the resource here, you’re done!</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>        return result;</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>. @end</p></li>
</ol>


<h3>戒律…</h3>

<p>理解自动释放池用来做什么，什么时候为你创建与释放，以及什么时候你需要自己来创建和释放它。</p>

<ul>
<li><p>由NSRunLoop在每一个循环自动创建及释放</p></li>
<li><p>由NSOperation自动创建及释放</p></li>
<li><p>在线程的开始及结尾处手动创建及释放</p></li>
<li><p>每当你需要在某个循环中创建及释放大量对象的时候，在循环外手动创建及释放</p></li>
</ul>


<p>在ARC模式下，你通过@autoreleasepool{&hellip;}指令来创建自动释放池。</p>

<hr />

<h3>戒律…</h3>

<p><strong>总是</strong>倾向于使用类层面的便利构造函数，而非init构造函数。所有基础框架里的容器类都提供这些。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p><a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSMutableDictionary_Class/">NSMutableDictionary</a>* dict = [[<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSMutableDictionary_Class/">NSMutableDictionary</a> alloc]init];</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p><a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSMutableDictionary_Class/">NSMutableDictionary</a>* dict = [<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSMutableDictionary_Class/">NSMutableDictionary</a>dictionary];</p>

<hr />

<h3>戒律…</h3>

<p><strong>总是</strong>在你所写类的接口中提供类层面的便利构造函数。</p>

<h3>为什么?</h3>

<p>这样你所写类的使用者就能够遵循上面那条戒律了。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (id)initWithBar:(int)bar baz:(int)baz;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@interface Foo : <a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a></p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (id)initWithBar:(int)bar baz:(int)baz;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>+ (Foo*)fooWithBar:(int)bar baz:(int)baz;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<hr />

<h3>戒律…</h3>

<p><strong>一定</strong>要理解对象所有权的转移什么时候会发生。ARC会帮你处理很多，但你还是得知道在背后到底发生了什么。</p>

<p>常见的获得对象所有权的方法：</p>

<ul>
<li><p>当你对一个类调用+alloc的时候你就拥有了新对象。</p></li>
<li><p>当你对一个实例调用-copy或者-mutableCopy的时候你就拥有了新对象。</p></li>
<li><p>当你将对象赋值给retain或者strong属性时，你就成为了该对象的拥有者。</p></li>
</ul>


<p>常见的释放对象所有权的方法：</p>

<ul>
<li><p>Assign another object (or nil) to a property with the (strong) attribute.</p></li>
<li><p>Let an owning local variable go out of scope.</p></li>
<li><p>Another object holding a reference to the object is destroyed.</p></li>
<li><p>将另一个对象(或者nil)赋值给strong属性。</p></li>
<li><p>本来拥有其所有权的一个局部变量超出了其生命周期范围。</p></li>
<li><p>拥有该对象引用的另一个对象被释放了。</p></li>
</ul>


<hr />

<h3>戒律…</h3>

<p><strong>一定要</strong>理解你属性和实例变量的内存管理策略，尤其当你在写自己的getter和setter时。确保你的实例变量上定义的存储策略是正确的，这样ARC才会正确工作。最简单的办法是单用一个@synthesize，然后覆盖setter及/或getter，在其中访问名字带下划线的实例变量，其行为跟属性中所声明的存储策略是一致的。</p>

<ol>
<li></li>
</ol>


<p>@interface bar</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@property (strong, nonatomic) id foo;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<ol>
<li></li>
<li></li>
<li></li>
</ol>


<p>@implementation bar</p>

<ol>
<li></li>
<li><p>.</p></li>
</ol>


<p>@synthesize foo = foo_;</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>- (id)foo</p>

<ol>
<li>.</li>
</ol>


<p>{</p>

<ol>
<li>.</li>
</ol>


<p>        return foo_;</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>- (void)setFoo:(id)foo;</p>

<ol>
<li>.</li>
</ol>


<p>{</p>

<ol>
<li>.</li>
</ol>


<p>        foo_ = foo;  // Retained/released automatically by ARC because of (strong) attribute on @property above</p>

<ol>
<li>.</li>
</ol>


<p>        [self syncToNewFoo];  // The reason for our custom setter</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li>.</li>
</ol>


<p> @end</p>

<hr />

<h3>戒律…</h3>

<p><strong>永远不要</strong>在你类中出现-dealloc方法，除非需要释放一些特殊的资源(关闭文件，释放由malloc()申请的内存，使定时器失效等)。其他的事情ARC都会帮你做的。</p>

<hr />

<h3>戒律…</h3>

<p>只要你为属性加上了自己写的setter，那么<strong>总是</strong>也要加上自己写的getter，反之亦然。</p>

<h3>为什么?</h3>

<p>Getter和setter在内存管理、线程安全以及其他一些它们可能会造成副作用的地方需要有对等的行为。你不能指望一个合成的getter或setter能跟一个自己写的getter或setter有对等的行为。因此，如果你打算自己写一个getter或者setter的话，请你两个都写上。</p>

<hr />

<h3>戒律…</h3>

<p>如果你<strong>总是</strong>需要在释放一个对象的时候做一些事情(比如使定时器失效)，那么你<strong>一定要</strong>为它的属性自己写一个setter，然后在你的-dealloc方法中将属性置为nil。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@synthesize myTimer;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (void)dealloc</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        self.myTimer = nil; // 定时器没有置为失效，在对象回收后我们可能还会收到回调！</p>

<ol>
<li></li>
</ol>


<p>}</p>

<ol>
<li></li>
<li><p>.</p></li>
</ol>


<p>@end</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@synthesize myTimer = myTimer_;</p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/">NSTimer</a>*)myTimer</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        return myTimer_;</p>

<ol>
<li></li>
</ol>


<p>}</p>

<ol>
<li></li>
<li><p>.</p></li>
</ol>


<p>- (void)setMyTimer:(<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/">NSTimer</a>*)myTimer</p>

<ol>
<li>.</li>
</ol>


<p>{</p>

<ol>
<li>.</li>
</ol>


<p>        [myTimer_ invalidate];</p>

<ol>
<li>.</li>
</ol>


<p>        myTimer_ = myTimer;</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>- (void)dealloc</p>

<ol>
<li>.</li>
</ol>


<p>{</p>

<ol>
<li>.</li>
</ol>


<p>        self.myTimer = nil; // 定时器在对象消失后肯定不会再回调了！在ARC模式下也需要这样。</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@end</p>

<h3>为什么?</h3>

<p>ARC负责在-dealloc的时候释放你的strong或retain实例变量，但它是直接释放变量，而不会调用你自己写的setter。因此如果你自己写的setter有其他的一些副作用(比如使定时器失效)，你还是得自己去调用它。</p>

<hr />

<h3>戒律…</h3>

<p>在写构造函数的时候，<strong>一定不要</strong>在[super init]调用前写很多代码，写得越少越好。</p>

<h3>为什么?</h3>

<p>一般情况下，对父类构造函数的调用有肯能会失败，导致调用返回nil。如果发生这样的事，在调用父类构造函数之前你所做的一切初始化工作将变得毫无价值，甚至是有害的，必须要撤销。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (id)initWithBar:(Bar*)bar</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        [bar someMethod];</p>

<ol>
<li></li>
</ol>


<p>        // other pre-initialization here</p>

<ol>
<li></li>
<li></li>
</ol>


<p>        if(self = [super init]) {</p>

<ol>
<li></li>
</ol>


<p>                // other initialization here</p>

<ol>
<li>.</li>
</ol>


<p>        } else {</p>

<ol>
<li>.</li>
</ol>


<p>        // oops! failed to initialize super class</p>

<ol>
<li>.</li>
</ol>


<p>        // undo anything we did above</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>        return self;</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@end</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (id)init</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        if(self = [super init]) {</p>

<ol>
<li></li>
</ol>


<p>                // minimal initialization here</p>

<ol>
<li></li>
</ol>


<p>        }</p>

<ol>
<li></li>
<li></li>
</ol>


<p>        return self;</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>// Other methods that put a Foo into a usable state</p>

<ol>
<li><p>.</p></li>
<li><p>.</p></li>
</ol>


<p>@end</p>

<hr />

<h3>戒律…</h3>

<p>当你没有使用nib文件在写UIViewController的时候，<strong>一定要</strong>在-loadView中创建你的视图层次结构，永远不要在-init中做。你<strong>只能够</strong>在-loadView的实现中对view属性进行赋值。</p>

<hr />

<h3>戒律…</h3>

<p><strong>永远不要</strong>自己调用-loadView！UIViewController的view属性在它被访问时会懒加载。它也会在低内存情况下被自动清除。因此<strong>永远不要</strong>假设UIViewController的view会跟controller活的一样长。</p>

<hr />

<h3>戒律…</h3>

<p><strong>总是</strong>只创建你需要的视图一次，然后在必要时展示、隐藏或移动它们。<strong>永远不要</strong>在每次一有变化就重复回收和再创建你的视图层次结构。</p>

<hr />

<h3>戒律…</h3>

<p>永远不要自己在UIView上调用-drawRect。可以调用-setNeedsDisplay。</p>

<hr />

<h3>戒律…</h3>

<p><strong>一定</strong>要避免在代码中做很长很复杂的操作。局部变量是你的朋友。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p><a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSMutableDictionary_Class/">NSMutableDictionary</a>* listDict = [[<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSMutableDictionary_Class/">NSMutableDictionary</a>alloc] initWithDictionary:[[<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSUserDefaults_Class/">NSUserDefaults</a>standardUserDefaults] objectForKey:@&ldquo;foo&rdquo;]];</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p><a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSUserDefaults_Class/">NSUserDefaults</a>* defaults = [<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSUserDefaults_Class/">NSUserDefaults</a>standardUserDefaults];</p>

<ol>
<li></li>
</ol>


<p><a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSDictionary_Class/">NSDictionary</a>* dataModelDict = [defaults objectForKey:@&ldquo;foo&rdquo;];</p>

<ol>
<li></li>
</ol>


<p><a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSMutableDictionary_Class/">NSMutableDictionary</a>* listDict = [<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSMutableDictionary_Class/">NSMutableDictionary</a>dictionaryWithDictionary:dataModelDict];</p>

<h3>为什么?</h3>

<ul>
<li><p>自说明</p></li>
<li><p>易于理解</p></li>
<li><p>调试器易于追踪代码</p></li>
</ul>


<hr />

<h3>戒律…</h3>

<p>当你没有在画什么东西的时候，方法名永远不要类似于-drawUI这样。总是用类似于-setupUI或者-resetUI这样的名字，尤其是当方法可能被调用不止一次的时候。</p>

<hr />

<h3>戒律…</h3>

<p><strong>永远不要</strong>重复。针对每个信息或者功能，都有个地方单独存放，程序中哪里能够用到就部署进去，甚至意味着有时候要触及到他人的代码。<strong>永远不要</strong>通过复制粘贴来编程。</p>

<hr />

<p>2010.10.15更新</p>

<h3>戒律…</h3>

<p><strong>永远不要</strong>调用-stringWithString，除非你：</p>

<ul>
<li><p>正将NSString转为NSMutableString。</p></li>
<li><p>正将NSMutableString转为NSString。</p></li>
<li><p>需要保证你正在处理的NSString*确实是不可变的。</p></li>
<li><p>真的需要一份NSMutableString的拷贝，因为你打算分别修改它们。</p></li>
</ul>


<h3>为什么?</h3>

<p>NSString是不可变的。一定不要去拷贝一个NSString，除非你想要一份可变的拷贝，或者确保一个你想保存的NSString的指针并没有变为NSMutableString的指针(那样的话，之后其他代码可能会改变了它的值)。实际上，试图拷贝NSString的行为仅仅是增加了该字符串的引用计数，然后再返回该字符串本身。
[/code]</p>

<hr />

<p>2012.04.26新增</p>

<h3>戒律&hellip;</h3>

<p>对于那些可以接收有可变子类的对象(像NSString或NSArray)的属性，存储类型<strong>一定要</strong>使用(copy)。</p>

<h3>为什么?</h3>

<p>属性的(copy)存储类型(还有-copy方法)总是产生这些对象的不可变拷贝。因此你可以依靠这些拷贝的不可变性（译者注：不用担心会改变原来对象的值），而你不能依靠原来对象的不可变性。这也是对调用者的一个承诺：你将不会改变通过这种方式传给你的对象的值，即使你不小心改变了该对象拷贝的值（译者注：也不会影响原对象的值）。</p>

<hr />

<h3>戒律&hellip;</h3>

<p>When overriding a method in a superclass, <strong>ALWAYS</strong> call the superclass&#8217; implementation,<strong>even if</strong> you know that super&rsquo;s implementation does nothing, <strong>unless</strong> you have a very good reason to not call super&rsquo;s implementation, in which case you <strong>must</strong> document your reason in the comments.</p>

<p>当覆盖父类中的某个方法时，<strong>总是</strong>要调用父类的实现，<strong>即使</strong>你知道父类的实现什么事情也没做，<strong>除非</strong>你有不调用父类实现的很好的理由，这种情况下你必须在注释中写下你的理由。</p>

<h3>为什么?</h3>

<ul>
<li><p>父类的实现在将来可能不会一直什么都不做。</p></li>
<li><p>可能有其他类最终会介入到你的类和你的父类之间，并且对父类的这个方法有一个非空的实现。</p></li>
<li><p>使你的代码更加能自说明，看你的代码就能知道这是个覆盖父类的方法，因为调用了父类的实现。</p></li>
</ul>


<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (void)awakeFromNib</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        // do my setup</p>

<ol>
<li></li>
</ol>


<p>}</p>

<ol>
<li></li>
<li></li>
</ol>


<p>@end</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>@implementation Foo</p>

<ol>
<li></li>
<li></li>
</ol>


<p>- (void)awakeFromNib</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        [super awakeFromNib];</p>

<ol>
<li></li>
<li></li>
</ol>


<p>        // do my setup</p>

<ol>
<li></li>
</ol>


<p>}</p>

<ol>
<li></li>
<li><p>.</p></li>
</ol>


<p>@end</p>

<hr />

<p>2010.10.15新增</p>

<h3>戒律&hellip;</h3>

<p>在条件语句中，<strong>永远不要</strong>把指针或数值当成布尔值。</p>

<h3>为什么?</h3>

<p>布尔值有两个值：true和false(按照Objective-C的习惯我们使用YES和NO)。而指针的值是一个对象或者nil。数值的值是某个数或0。在条件语句上下文中，o和nil和布尔值的false是等同的，这是一种形式的隐式类型转换，会让你的代码难以理解。因此要显式的测试这些值，对于指针看它是否等于nil，对于整型看它是否等于0，对于浮点看它是否等于0.0，等等。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>- (void)fooWithBar:(Bar*)bar baz:(BOOL)baz quux:(float)quux</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        if(bar &amp;&amp; baz &amp;&amp; quux) {</p>

<ol>
<li></li>
</ol>


<p>                // do something interesting</p>

<ol>
<li></li>
</ol>


<p>        }</p>

<ol>
<li></li>
</ol>


<p>}</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>- (void)fooWithBar:(Bar*)bar baz:(BOOL)baz quux:(float)quux</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        if(bar != nil &amp;&amp; baz &amp;&amp; quux != 0.0) {</p>

<ol>
<li></li>
</ol>


<p>                // do something interesting</p>

<ol>
<li></li>
</ol>


<p>        }</p>

<ol>
<li></li>
</ol>


<p>}</p>

<hr />

<p>2010.10.15新增</p>

<h3>戒律&hellip;</h3>

<p><strong>NEVER</strong> use conditional statements to check for nil when you don&rsquo;t have to. In particular, understand that in Objective-C, the act of calling any method on a nil object reference is a no-op that returns zero (or NO, or nil), and write your code accordingly.</p>

<p>当没必要的时候，<strong>永远不要</strong>用条件语句去测试是否为nil。特别的是，在Objective-C里，在nil对象上调用任何方法相当于做了一步返回值为0(或者NO，或者nil)的空操作，你应该相应去写你的代码。</p>

<h3>坏的做法</h3>

<ol>
<li></li>
</ol>


<p>- (void)setObj:(<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>*)obj</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        if(obj_ != nil) {</p>

<ol>
<li></li>
</ol>


<p>                [obj_ doCleanup];</p>

<ol>
<li></li>
</ol>


<p>        }</p>

<ol>
<li></li>
</ol>


<p>        if(obj != nil) {</p>

<ol>
<li></li>
</ol>


<p>                [obj doSetup];</p>

<ol>
<li></li>
</ol>


<p>        }</p>

<ol>
<li></li>
</ol>


<p>        obj_ = obj;</p>

<ol>
<li>.</li>
</ol>


<p>}</p>

<h3>好的做法</h3>

<ol>
<li></li>
</ol>


<p>- (void)setObj:(<a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/">NSObject</a>*)obj</p>

<ol>
<li></li>
</ol>


<p>{</p>

<ol>
<li></li>
</ol>


<p>        [obj<em> doCleanup]; // Does nothing if obj</em> == nil</p>

<ol>
<li></li>
</ol>


<p>        [obj doSetup]; // Does nothing if obj == nil</p>

<ol>
<li></li>
</ol>


<p>        obj_ = obj;</p>

<ol>
<li></li>
</ol>


<p>}</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/08/15/xcodee4b8ade79a84e5ad90e9a1b9e79baeefbc88e8af91e69687efbc89/">Xcode中的子项目（译文）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-15T15:44:18+08:00" pubdate data-updated="true">Aug 15<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文网址：<a href="http://www.cocoanetics.com/2011/12/sub-projects-in-xcode/">http://www.cocoanetics.com/2011/12/sub-projects-in-xcode/</a></p>

<p>================</p>

<p>Xcode有一个非常有趣但没有出现在文档中的功能，是你可以在你的项目结构中加入子项目。你可以在你的项目中加入xcodeproj，然后指向该项目的输出。</p>

<p>如果你在某个项目中开发了某个功能，现在想在另一个项目中使用这个完善的功能，那么子项目对你来说尤其有用。举例来说，你想给你的应用加上访问从Safari上拷贝过来的HTML代码的能力，需要用到我的<a href="http://cocoanetics.github.com/DTWebArchive/">DTWenArchive</a>类。要么你可以把所有的类拷贝到你的项目中，要么编译出两个库（一个为模拟器，一个为设备，或者整合到一块），要么编译一个静态的通用框架。</p>

<p>还有第四种方法我要在这篇文章中告诉你。这个方法既不需要你拷贝源代码，也不需要预先编译什么。</p>

<p>注意对Xcode4.2来讲，可能搞定之前你会遇到些麻烦。有人告诉我说他在Xocde 3上做了以下我将要说的内容，然后搞定了。总之这两种方法总有一种是行的通的，要是行不通，那肯定是“你把它搞错了”。<img src="http://www.cocoanetics.com/wp-includes/images/smilies/icon_wink.gif" alt=";-)" /></p>

<h3>子项目，一个被忽视的选项</h3>

<p>这是我自己第一次使用子项目。我的DTRichTextEditor框架很多地方用到了我的两个开源项目。我机器上的项目结构是这样的：</p>

<p><img src="/images/2012/08/1.png"></p>

<p>文件系统结构和组结构基本一致。我有一个叫Externals的文件夹，里面有这两个GitHub项目的克隆。当你把xcodeproj加入到你项目中时，它会变成如图所示这样，你可以同时看到子项目中的源代码。更赞的是，当你调试的时候，你可以单步调试到子项目中的代码，就好像它们在本地一样。</p>

<p>有一些要注意的地方，有时候重启几次Xcode后项目结构树才会显示出来。Xcode似乎对你同时打开子项目有意见。如果你那么做的话，你会得到一个出错消息，说子项目的一致性无法验证。因此确保你不要把子项目也同时打开。你可以在大项目中编辑子项目的代码。</p>

<h3>准备子项目</h3>

<p>要能够如上所示使用xcodeproj，你需要准备一些东西，我来给你介绍。</p>

<p>你至少需要有一个用来编译iOS静态库的target。在你项目根文件中添加这么一个target。然后选择头文件和实现文件加入这个库。</p>

<p><img src="/images/2012/08/11.png"></p>

<p>我喜欢将target的命名和产品不一样。我想让target名叫“Static Library”，然后在build settings中将产品命名为DTWebArchive，这样Producs下便产生了一个叫libDTWebArchive.a的产品。</p>

<p>你不需要在project, private和public中修改头文件。将头文件从默认的project改为其他的，仅仅是将头文件拷到了产品输出路径上，这几乎没什么用。你也会想要改Scheme的名字，或者为你的targets自动生成schemes。这些scheme只是为了你个人方便，它们甚至没有保存在xcodeprj文件中。</p>

<p>确保你的库构建没有任何警告或错误。注意如果你没有选择任何源文件的话，libtool也会失败，但没有有用的错误信息。这种情况在我身上发生过几次。</p>

<h3>添加子项目</h3>

<p>当你对静态库满意时，将该项目关闭，然后打开另一个即将包含它的项目。根据你实际情况，你可以将所有的项目放在同一个路径下互相挨着对方，也可以让大项目在物理目录上也包含小项目。我推荐后者，因为你的文件系统结构可能和其他编译这个项目的人不一样。如果你使用了绝对路径，或相对路径指向了项目根文件夹外的地方，你会自找麻烦的。</p>

<p>当添加子项目的时候，你不需要将它选为任何target的成员。最好你在Finder中将xcodeproj拖入项目中。</p>

<p>接下来你需要在build settings中添加路径，以便可以寻找到子项目的头文件。你不能将.h文件加入你的主项目中，但你可以告诉编译器哪里可以找到它们。指定相对于你项目跟文件夹的路径。我选择了recursive，因为我有多个子项目，这样的话我仅需要指定该设置一次。</p>

<p><img src="/images/2012/08/12.png"></p>

<p>这样搭建好以后，你可以跟往常一样使用import语句来导入子项目中的头文件了。</p>

<p>你告诉链接器在子项目中链接静态库。在Build Phasese选项卡的“Link Binary With Libraries”下设置。你可能想把静态库改为&#8221;Required&#8221;，因为我们无法构建动态库（dylib），苹果在他们的框架中已经使用了。</p>

<p><img src="/images/2012/08/13.png"></p>

<p>你还要将静态库targets加为依赖。这样的话编译系统就知道如果在依赖中的代码有变更的话，它需要重新编译应用目标代码。</p>

<p>如果你只用过c语言编程，那就算了。但既然我们用Objective-C编程（可能使用了ARC），我们需要加上“Other Linker Flags”：</p>

<ul>
<li><p><strong>-ObjC</strong>  否则的话链接器不会加载你的类</p></li>
<li><p><strong>-all_load</strong> 如果你的库中有分类，不加的话分类得不到加载</p></li>
<li><p><strong>-fobjc-arc</strong> 如果你连接的库使用了ARC而你的应用没有使用ARC</p></li>
</ul>


<p>事实上前两个非常标准，因此如果你搞过静态库的话肯定已经接触过了。</p>

<h3>结论</h3>

<p>你看，没多少工作量的，你可以不用再把需要复用的代码拷贝的到处都是了。你最好把它们放进你自己的基础框架（就像我自己的<a href="http://cocoanetics.github.com/DTFoundation/">DTFoundation</a>），加上文档和恰当的单元测试。这样的话你加入的任何新方法或者做的任何改进都能使得你所有的应用受益，而不仅仅是你当前开发中的应用。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/08/13/e5ada6e4b9a0ios-5e4b8ade79a84arc-e7acace4b880e983a8e58886-efbc88e8af91e69687efbc89/">学习iOS 5中的ARC 第一部分 （译文）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-13T13:28:39+08:00" pubdate data-updated="true">Aug 13<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文网址：<a href="http://www.raywenderlich.com/5677/beginning-arc-in-ios-5-part-1">http://www.raywenderlich.com/5677/beginning-arc-in-ios-5-part-1</a></p>

<p>================</p>

<p>这篇的作者是iOS教程团队成员<em><a href="http://twitter.com/#!/mhollemans">Matthijs Hollemans</a>，</em>一位经验丰富的iOS开发者与设计师。</p>

<p>iOS 5中最大的变化是引入了自动引用计数，简称ARC。ARC是最新的LLVM3.0编译器的特性，它完全废除了所有iOS开发者都讨厌的手动内存管理。</p>

<p>在项目中使用ARC极其简单。你还是跟往常一样写代码，只不过不要再用retain, release和autorelease了。基本上没什么大的变化。</p>

<p>当开启了自动引用计数特性，编译器会自动在你程序的相应位置插入retain, release和autorelease。你不再需要考虑这些（何时在哪里插入retain/release/autorelease，译者注），因为编译器都为你搞定了。我觉得这超级赞。事实上，使用ARC太简单了，以至于你都不需要读这份教程了。:)</p>

<p>但如果你依然对ARC有所怀疑——可能你觉得它不会一直都很靠谱，亦或者你觉得它会比你手动管理内存来得慢——那就继续阅读下去吧。接下来这篇教程将为你扫清疑云，向你展示在项目中开启ARC以后，背后会发生些什么。</p>

<p>除此之外，你将会亲自将一个不使用ARC的项目转变为使用ARC。同样的，你可以将你自己以前的项目转为ARC，这样就能部位内存管理而烦恼啦。</p>

<h2>工作原理</h2>

<p>你肯定已经对手动内存管理比较熟悉了，它的工作原理如下：</p>

<ul>
<li><p>如果你要保留一个对象，你需要对它retain，除非它已经被retain过了。</p></li>
<li><p>如果你不再需要这个对象了，你需要对它release，除非它已经被release过了（用了autorelease）。</p></li>
</ul>


<p>作为初学者，你肯定被它搞得头痛过，不过过段时间这概念就被条件反射般记住，你会保持retain和release数量的平衡，除非你忘了。</p>

<p>手动内存管理的原理并不复杂，但很容易让你出错。这些小错误会导致可怕的后果。你的程序会在某一时刻崩溃，要么由于你对某个对象释放的次数太多，导致你的变量指向了不合法的数据，要么由于内存耗完了，因为你没释放对象，它们一直占着内存。</p>

<p>Xcode的静态分析器可以帮你有效地发现这类问题，但是ARC可以更进一步。它自动帮你适时地插入retain和release，帮你完全摆脱内存管理问题！</p>

<p>需要意识到，ARC是Objective-C编译器的一个特性，ARC发生在你构建程序时。ARC不是运行时特性（除了一小部分，弱指针系统），也不是你所知道的其他语言中的垃圾收集机制。</p>

<p>ARC所做的只是编译时在你代码中插入retain和release，跟你自己来做没什么两样。这就使得ARC跟手动管理的代码一样快，甚至有时候还会更快一点，因为它会在后台执行一些优化。</p>

<h2>通过指针保持对象存活</h2>

<p>你需要学习的ARC的新规则非常简单。对于手动内存管理，你需要使用retain来保持对象存活，而现在都不需要了。你要做的只是用一个指针指向这个对象。只要有变量指向该对象，该对象就会一直存在内存中。当该指针指向了新的值，或者指针不存在了，与之关联的对象才会被release。对所有变量都是这样：实例变量，已合成属性，甚至局部变量。</p>

<p>可以把这想成是一种拥有关系。如下代码：</p>

<pre><code>NSString *firstName = self.textField.text;
</code></pre>

<p>firstName变量是一个指向NSString对象的指针，持有textField的内容。firstName变量现在就成为了字符串对象的拥有者。</p>

<p><img src="/images/2012/08/Pointers1.png"></p>

<p>一个对象可以有一个以上的拥有者。在用户改变UITextField里的内容之前，UITextField的text属性也是这个字符串对象的拥有者。有两个指针保持同一个字符串对象存活：</p>

<p><img src="/images/2012/08/Pointers2.png"></p>

<p>过一阵子，用户会在输入框中输入一些新的内容，这时输入框的text属性指向了一个新的字符串对象。但原来的字符串对象仍然有一个拥有者（firstName变量），因此它还在内存中。</p>

<p><img src="/images/2012/08/Pointers3.png"></p>

<p>只有当firstName也有了新值，或者不在其生命周期范围内了——因为它是局部变量而方法结束了，或者因为它是实例变量而它所属对象被回收了——这种拥有关系才会结束。原来的字符串对象没有拥有者了，它的引用计数降为0，因而该对象就被回收了。</p>

<p><img src="/images/2012/08/Pointers4.png"></p>

<pre><code>__weak &lt;a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/"&gt;NSString&lt;/a&gt; *weakName = self.textField.text;
</code></pre>

<p>我们称像firstName和textField.text这样的指针为“强”类型，因为它们可以保持对象存活。默认情况下所有的实例变量和局部变量都是强指针。</p>

<p>同时也存在“弱”指针。弱类型的变量仍然可以指向其他对象，但是它们并不拥有这些对象：</p>

<pre><code>__weak NSString *weakName = self.textField.text;
</code></pre>

<p><img src="/images/2012/08/Pointers5.png"></p>

<p>weakName变量和textField.text属性指向了同一个变量，但并非是其拥有者。如果输入框中内容改变，那么字符串对象将没有了拥有者，从而被回收：</p>

<p><img src="/images/2012/08/Pointers6.png"></p>

<p>当这发生时，weakName的值将会自动变为nil。此弱指针被成为“自动清零”弱指针。</p>

<p>这极其的方便，因为这能防止弱指针指向已经被回收的内存。这种事情会造成大量的bug——你肯定听说过“野指针”或者“僵尸”——但多亏这些自动清零的弱指针避免了这种情况！</p>

<p>你可能不会经常使用弱指针。它最有用是用在两个对象有父子关系的时候。父对象拥有一个强指针指向子对象——即“拥有”了子对象——但为了避免循环引用，子对象只能用弱指针指回它的父对象。</p>

<p>代理模式便是这种例子。你的view controller通过强指针拥有了UITableView。table view的数据源和代理指针指回view controller，但使用弱引用。我们一会再谈这个。</p>

<p><img src="/images/2012/08/Pointers7.png"></p>

<p>以下代码并不是很有用：</p>

<pre><code>__weak NSString *str = [[NSString alloc] initWithFormat:...];
NSLog(@"%@", str);  // will output "(null)"
</code></pre>

<p>字符串对象没有拥有者（因为str是弱指针），因此它刚刚被创建完立马就被回收了。当你这么做的时候，Xcode会给出警告，因为结果并非你所预期（“警告：将retain对象赋给弱变量；对象在赋值结束后将被回收”）。</p>

<p>你可以使用__strong关键字来表示一个强指针：</p>

<pre><code>__strong NSString *firstName = self.textField.text;
</code></pre>

<p>但因为默认情况下变量就是强类型的，所以这有点多此一举。</p>

<p>属性同样可以是强或弱类型。属性的表示法如下：</p>

<pre><code>@property (nonatomic, strong) NSString *firstName;
@property (nonatomic, weak) id &lt;MyDelegate&gt; delegate;
</code></pre>

<p>ARC很棒，它可以真正帮你去掉代码中一堆乱七八糟的东西。你不再需要去想何时retain，何时release，只需要去想你的对象之间是个什么关系。你只需要问自己：谁拥有什么？</p>

<p>举例来说，以前是不可能这样写代码的：</p>

<pre><code>id obj = [array objectAtIndex:0];
[array removeObjectAtIndex:0];
NSLog(@"%@", obj);
</code></pre>

<p>在手动内存管理下，将对象从数组中删除将会使obj变量中的内容失效。该对象一旦离开数组立马就被回收了。用NSLog()打印该对象很可能会使程序崩溃。使用了ARC以后，以上代码如预期一样正常工作。因为我们将对象放入了强指针obj，数组便不再是该对象的唯一拥有者了。即使我们从数组中删除了对象，该对象依然存活，因为obj保持着它的引用。</p>

<p>自动引用计数同样也有一些限制。对初学者来说，ARC机制只对Objective-C对象有效。如果你的应用使用了Core Foundation或者malloc()和free()，那你还是需要在那些地方使用手动内存管理。我们将在这篇教程的下面看到例子。除此之外，为了确保ARC总能正确工作，某些语言规则更加地严格了（译者注：可能是指代码中不准出现retain, release等规则）。这些只是小的牺牲，你得到的远比失去的要多！</p>

<p>ARC帮你在合适的地方retain和release，但并不意味着你可以完全将内存管理抛在脑后。因为强指针能使对象一直存活，所以仍然存在这样的情况：即你需要手动地将这些指针置为nil，否则你的应用将会耗尽内存。如果你始终保留着你创建的所有对象，那么ARC将永远没机会释放它们。因此，每当你创建一个新对象，你仍然需要思考谁拥有这个对象，以及该对象应该在内存中存在多长时间。</p>

<p>毫无疑问ARC是Objective-C的一个特性。苹果鼓励开发者别用手动内存管理，转而开始使用ARC开发他们的新应用。这使得源代码更简洁，程序更健壮。使用了ARC，内存有关的崩溃问题将成为历史。</p>

<p>但由于我们处在一个从手动到自动内存管理的转型时期，你会经常遇到一些和ARC尚不兼容的代码，不管是你自己的代码还是第三方库。幸运的是，你可以在同一个项目中同时使用ARC以及非ARC的代码，我会向你展示一些方法。</p>

<p>ARC甚至与C++磨合得很好。在一些限制条件下，你也可以在iOS4中使用ARC， which should only help to speed up the adoption（译者注：这句不是很懂）。</p>

<p>聪明的开发者尽可能地自动化自己的工作，ARC正能提供这样的好处：将以前你需要手动做的粗活累活自动化了。 对我来说，用脚趾头思考都会去改变。</p>

<h2>应用</h2>

<p>为了展示实践中如果使用自动引用计数，我准备了一个简单的应用，我们将把它从手动内存管理转为自动内存管理。这个艺术家应用只有一个屏幕，上面有一个表格视图和一个搜索框。当你在搜索框中输入的时候，应用会使用MusicBrainz API来查找匹配的音乐家的名字。</p>

<p>这个应用是这样子的：</p>

<p><img src="/images/2012/08/The-Artists-app.png"></p>

<p>用他们自己的话来说，MusicBrainz是“一个开放的音乐百科全书，收集音乐元数据，并供大众使用”。他们有一个免费的XML web服务供你的应用使用。想了解MusicBrainz的话，请访问他们的网站<a href="http://musicbrainz.org/">http://musicbrainz.org</a>。</p>

<p>继续，下载这篇教程的<a href="http://cdn1.raywenderlich.com/downloads/ArtistsStarter.zip">第一个项目</a>，在Xcode中打开。该项目有以下源代码：</p>

<ul>
<li><p><strong>AppDelegate.h/.m</strong>：应用代理。这儿没什么特别之处，每个应用都有。它负责加载view controller，把它放入窗口。</p></li>
<li><p><strong>MainViewController.h/.m/.xib</strong>：应用的view controller，有一个表格视图和一个搜索框，大多数工作都在这进行。</p></li>
<li><p><strong>SoundEffect.h/.m</strong>：一个播放音效的简单的类。应用会在MusicBrainz搜索完成后发出“哔”的一声。</p></li>
<li><p><strong>main.m</strong>：应用的入口。</p></li>
</ul>


<p>除此之外，应用使用了第三方库。你的应用很可能使用了一些外部组件，正好让我们学习下如果让这些库支持ARC。</p>

<ul>
<li><p><strong>AFHTTPRequestOperation.h/.m</strong>：AFNetworking库中的一部分，简化了向web服务发请求的过程。我没有引入整个库，因为我们仅需要这一个类。你可以在这找到完整的包：<a href="https://github.com/gowalla/AFNetworking%E3%80%82">https://github.com/gowalla/AFNetworking%E3%80%82</a></p></li>
<li><p><strong>SVProgresHUD.h/.m/.bundle</strong>： 一个进度指示器，当搜索发生时我们将展示在屏幕上。你以前可能没见过.bundle文件。这是一个特殊类型的文件夹，包括了SVProgressHUD用到的图片文件。要看到这些图片，在Finder中右键.bundle文件，选择显示包内容菜单选项。 了解更多该组件内容，请看： <a href="https://github.com/samvermette/SVProgressHUD%E3%80%82">https://github.com/samvermette/SVProgressHUD%E3%80%82</a></p></li>
</ul>


<p>让我们快速浏览view controller的代码以了解应用的工作机制。MainViewController是UIViewController的子类。它的nib文件包含了UITableView对象和UISearchBar对象：</p>

<p><img src="/images/2012/08/Nib.png"></p>

<p>表格视图展示了searchResults数组的内容。起初，该指针为nil。当用户搜索了，我们将MusicBrainz服务器的返回填入数组中。如果没有搜索结果，该数组为空（但不为nil），表格显示“（没找到）”。这一切都在UITableViewDataSource方法中发生：numberOfRowsInSection和cellForRowAtIndexPath。</p>

<p>真正的搜索在searchBarSearchButtonClicked方法中初始化，该方法是UISearchBarDelegate协议的一部分。</p>

<pre><code>- (void)searchBarSearchButtonClicked:(UISearchBar *)theSearchBar
{
    [SVProgressHUD showInView:self.view status:nil
      networkIndicator:YES posY:-1
      maskType:SVProgressHUDMaskTypeGradient];
</code></pre>

<p>首先，我们创建新的HUD，在表格数据和搜索条的上方展示它。网络请求返回前阻止用户输入：</p>

<p><img src="/images/2012/08/HUD.png"></p>

<p>然后我们创建HTTP请求用的URL。我们用MusicBrainz API来搜索艺术家。</p>

<pre><code>SString *urlString = [NSString stringWithFormat:
  @"http://musicbrainz.org/ws/2/artist?query=artist:%@&amp;limit=20",
  [self escape:searchBar.text]];
NSMutableURLRequest *request = [NSMutableURLRequest
  requestWithURL:[NSURL URLWithString:urlString]];
</code></pre>

<p>搜索文本使用转义符进行URL编码：为确保我们使用合法的URL。空格以及其他特殊字符转为这样的东东：%20。</p>

<pre><code>NSDictionary *headers = [NSDictionary dictionaryWithObject:
  [self userAgent] forKey:@"User-Agent"];
[request setAllHTTPHeaderFields:headers];
</code></pre>

<p>我们在HTTP请求里加入了自定义的User-Agent头。MusicBrainz API需要这个。所有的请求必须“有一个合适的能够标识应用以及应用版本的User-Agent头”。按照你使用的API说的去做就对了，因此我们构建了这样的User-Agent头：</p>

<pre><code>com.yourcompany.Artists/1.0 (unknown, iPhone OS 5.0,
  iPhone Simulator, Scale/1.000000)
</code></pre>

<p>（我从AFNetworking库的另一部分找到了以上东东，把它放到view controller里的userAgent方法中。）</p>

<p>MusicBrainz API还有些其他的限制。客户端应用每秒钟不能调用超过一次web服务，否则他们可能会封IP。对我们的应用来说不是什么大问题——用户不大可能搜索那么多次——所以我们没有特别的预防措施。</p>

<p>一旦我们构建了NSMutableURLRequest对象，我们把它交给AFHTTPRequestOperation来执行：</p>

<pre><code>AFHTTPRequestOperation *operation = [AFHTTPRequestOperation
  operationWithRequest:request completion:^(NSURLRequest *request,
  NSHTTPURLResponse *response, NSData *data, NSError *error)
  {
    // ...

  }];

  [queue addOperation:operation];
</code></pre>

<p>AFHTTPRequestOperation是NSOperation的子类，意味着我们可以把它放进NSOperationQueue（在queue变量中），它将会被异步处理。由于HUD，应用在请求发生时忽略了任何用户输入。</p>

<p>我们给AFHTTPRequestOperation加上了block，当请求完成会执行block。在block中我们首先检查请求是否成功（HTTP状态码200）。对该应用来说，我们对应用失败的原因并不是很感兴趣，因此就仅仅让HUD消失前展示特殊的“错误”动画而已。注意到完成block不一定是在主线程上执行的，所以我们要把对SVProgressHUD的调用包在dispatch_async()中。</p>

<pre><code>if (response.statusCode == 200 &amp;&amp; data != nil)
{
    . . .
}
else  // something went wrong
{
    dispatch_async(dispatch_get_main_queue(), ^
    {
        [SVProgressHUD dismissWithError:@"Error"];
    });
}
</code></pre>

<p>现在到了有趣的部分。如果请求成功了，我们为searchResults数组分配控件，解析响应。响应是XML格式的，因此我们使用NSXMLParser来搞定。</p>

<pre><code>self.searchResults = [NSMutableArray arrayWithCapacity:10];

            NSXMLParser *parser = [[NSXMLParser alloc] initWithData:data];
            [parser setDelegate:self];
            [parser parse];
            [parser release];

            [self.searchResults sortUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
</code></pre>

<p>你可以在NSXMLParserDelegate方法中查看解析XML的逻辑，但本质上我们仅仅是寻找名字为“sort-name”的元素而已。这些元素包括了艺术家们的名字。我们把这些名字作为NSString对象加入到searchResults数组中。当XML解析器工作完毕，我们将结果按照字母排序，然后在主线程中更新屏幕。</p>

<pre><code>dispatch_async(dispatch_get_main_queue(), ^
{
    [self.soundEffect play];
    [self.tableView reloadData];
    [SVProgressHUD dismiss];
});
</code></pre>

<p>程序就是这样工作的。它是用手动内存管理来写的，并没有用到iOS5的特性。现在让我们把它转成ARC。</p>

<h2>自动转换</h2>

<p>我们将会把艺术家应用转成ARC。基本上这意味着我们要去除所有的retain, release和autorelease调用，但我们也会遇到一些需要特别注意的地方。</p>

<p>使得你的应用兼容ARC，你可以做以下三件事：</p>

<ol>
<li><p> Xcode有自动转换工具可以将你的代码整个迁移过去。</p></li>
<li><p> 你可以手工转换。</p></li>
<li><p> 你可以对一些你不想转换的源文件禁用ARC。这对于你不想乱改的第三方库来说很有用。</p></li>
</ol>


<p>在艺术家应用中我们将尝试每种方法，向你展示它的工作机制。在这一节中，我们将使用Xcode的自动转换工具来转换源代码，除了MainViewController和AFHTTPRequestOperation外。</p>

<p>在做之前，你应当对你的项目做一个备份，因为工具会覆盖原来的文件。Xcode提供了源文件的快照，但保险起见我还是做一下备份。</p>

<p>ARC是最新的LLVM3.0编译器的特性。你的现存项目很可能使用老的GCC 4.2或者LLVM-GCC编译器，因此可以先将项目换成用新的编译器来编译，先看看用非ARC模式来编译是否没问题。在Project Settings界面，选择艺术家target，在Build Settings的搜索框中输入“compiler”，Xcode会在列表中筛选出编译器选项：</p>

<p><img src="/images/2012/08/Compiler-settings.png"></p>

<p>点击 Compiler for C/C++/Objective-C 选项，选择Apple LLVM compiler 3.0：</p>

<p><img src="/images/2012/08/LLVM-compiler.png"></p>

<p>在Warnings栏目下，将Other Warning Flags（译者注：原文 Other Linker Flags，为作者笔误）选项设置为 -Wall。编译器现在将会检查所有可能会导致问题的情况。默认情况下这些警告都是关掉的，但我觉得打开所有的警告，像严重错误一样对待它们很有用。换句话说，如果编译器给出了警告，我会在继续工作前先修复它。在你自己的项目中是否这么做由你决定，但在转换为ARC的过程中，我推荐你好好关注下编译器给出的任何抱怨。</p>

<p>同样的原因，在Build Options栏目下打开 Run Static Analyzer选项：</p>

<p><img src="/images/2012/08/Run-Static-Analyzer.png"></p>

<p>现在Xcode会在你每次构建程序时运行静态分析器了。这使得构建过程稍微变慢，但对这么小的程序基本可以忽略。</p>

<p>让我们构建程序，来看下新编译器有没有什么问题。首先来 清理一下，打开Product->Clean菜单选项（或者Shift-Cmd-K）。然后按下Cmd-B来构建程序。Xcode应该不会给出错误或警告，这很棒。如果你将自己的应用转换为ARC，在这里有警告信息的话，你得修复它们。</p>

<p>单纯为了好玩，我们将编译器换成ARC模式，再次构建应用。我们将得到一堆错误消息，但都能看到具体是什么问题。</p>

<p>仍然在Build Settings界面，换成&#8221;All&#8221;来看所有的变量设置（不是Basic，Basic只显示用的最多的一些设置）。搜索“automatic”，将Objective-C Automatic Reference Counting设为Yes。这是一个对整个项目都有效设置项，它告诉Xcode要对项目中所有的源文件使用ARC编译器。</p>

<p><img src="/images/2012/08/Enable-ARC.png"></p>

<p>再次构建应用。欧~出现一堆错误：</p>

<p><img src="/images/2012/08/Errors.png"></p>

<p>很明显我们有一些迁移工作需要做！大多数的错误都非常明显，提醒你不能再使用retain，release和autorelease了。我们可以手动把这些错误都修复，但使用自动转换工具更加简单。这个工具可以在ARC模式下编译应用，遇到错误就会修改源代码，直到编译成功。</p>

<p>从Xcode的菜单上选择Edit\Refactor\Convert to Objective-C ARC。</p>

<p><img src="/images/2012/08/Convert-to-ARC.png"></p>

<p>跳出新窗口让你选择你想转换哪一部分程序：</p>

<p><img src="/images/2012/08/Select-targets-to-convert.png"></p>

<p>这篇教程不打算让我们转换整个应用，所以只要选择以下文件：</p>

<ul>
<li><p>main.m</p></li>
<li><p>AppDelegate.m</p></li>
<li><p>SVProgressHUD.m</p></li>
<li><p>SoundEffect.m</p></li>
</ul>


<p>这个对话框有个警告的图标，指示项目已经使用了ARC。那是因为我们之前在Build Settings中已经打开了 Automatic Reference Counting选项，现在转换工具就认为这已经是一个ARC项目了。这个警告可以忽略，不会影响转换结果。</p>

<p>点击Precheck按钮开始转换。工具会首先检查你的代码是否能够被转换成ARC。我们之前使用最新的LLVM3.0编译器成功编译过程序，但很明显这还不够。Xcode给出了以下的错误信息：</p>

<p><img src="/images/2012/08/Cannot-convert-error1.png"></p>

<p>它抱怨你的程序中有“ARC准备就绪问题”，提示我们应该打开“Continue building after errors”选项。我们首先来做后者。打开Xcode Preferences窗口（从Xcode下的菜单栏中），切换到General选项卡。选中 Continue building after errors:</p>

<p><img src="/images/2012/08/Continue-building-after-errors.png"></p>

<p>我们再试一次。选择Edit\Refactor\Convert to Objective-C ARC，勾选除MainViewController.m和AFHTTPRequestOperation.m外的所有文件，点击Precheck按钮开始。</p>

<p><img src="/images/2012/08/Cannot-convert-error-2.png"></p>

<p>不幸的是，依然有错误信息。和之前不同的是，这一次编译器能够识别出在转换前我们需要修复所有的问题。幸运的是，只有一个问题：</p>

<p><img src="/images/2012/08/Precheck-issues.png"></p>

<p>（你的错误可能比这里显示的更多。有时编译器还会抱怨那些非“ARC准备就绪”的问题。）</p>

<p>错误的详细描述如下：</p>

<pre><code>Cast of Objective-C pointer type 'NSURL *' to C pointer type 'CFURLRef' (aka 'const struct __CFURL *') requires a bridged cast
</code></pre>

<p>在源代码编辑器中是这样的：</p>

<p><img src="/images/2012/08/Cast-error.png"></p>

<p>这里我一会儿会详细阐述。这里的代码试图将一个NSURL对象转成一个CFURLRef对象。AudioServicesCreateSystemSoundID()函数用CFURLRef做参数，用来表示声音文件所在位置，但我们却给了它一个NSURL的对象。CFURLRef和NSURL是“toll-free bridged”（译者注：如果开发者混合使用Foundation Objects 和Core Foundation类型，就能充分利用存在两个框架中的&#8221;toll-free bridging&#8221;。toll-free bridging意味着开发者能使用这两个框架中的任何一个的核心基础和基础类型），意味着在用CFURLRef对象的地方可以用NSURL对象，反之亦然。</p>

<p>通常iOS中基于C的API会使用Core Foundation对象（CF的全称），而基于Objective-C的API使用继承于NSObject类的“真正”的对象。有时你需要在这两者之间转换，toll-free bridging技术允许你这么做。</p>

<p>然而，当你使用ARC的时候，编译器需要知道如果处理这些toll-free bridged对象。如果你在用CFURLRef的地方用了NSURL，那最后谁来释放那块内存？为了解决这个难题，引入了一系列新的关键词：<strong>bridge, </strong>bridge_transfer 和 __bridge_retained。教程后面我们会深入了解如何使用它们。</p>

<p>现在我们要把代码改成如下所示：</p>

<pre><code>OSStatus error = AudioServicesCreateSystemSoundID((__bridge CFURLRef)
  fileURL, &amp;theSoundID);
</code></pre>

<p>预检查过程可能给出了比这更多的错误。没事，你可以忽略那些错误，我们只需要在SoundEffect.m中如上面那样修改就行了。转换工具有时对什么是“ARC准备就绪问题”不太确定。</p>

<p>让我们再运行一次转换工具—— Edit\Refactor\Convert to Objective-C ARC。这次预检查过程没出现任何问题，我们得到了如下界面：</p>

<p><img src="/images/2012/08/Precheck-successful.png"></p>

<p>点击Next继续。几秒钟以后，Xcode会展示出它将改动的所有文件，以及它将做出哪些改动。左边的窗口是改完的文件，右边的是原来的文件。</p>

<p><img src="/images/2012/08/Review-Changes.png"></p>

<p>逐个查看这些文件，确保Xcode没有搞错。我们来看下转换工具即将做出的改动。</p>

<h2>AppDelegate.h</h2>

<pre><code>@property (strong, nonatomic) UIWindow *window;
@property (strong, nonatomic) MainViewController *viewController;
</code></pre>

<p>应用代理有两个属性，一个是窗口，一个是主视图控制器。该项目中没使用MainWindow.xib文件，所以这两个对象是由AppDelegate在application:didFinishLaunchingWithOptions:中自己创建的，存在属性中是为了简化内存管理。</p>

<p>这两个属性声明从这个</p>

<pre><code>@property (retain, nonatomic)
</code></pre>

<p>变成了</p>

<pre><code>@property (strong, non atomic)
</code></pre>

<p>strong关键字的意思你知道的。它告诉ARC，属性背后合成的ivar变量对涉及到的对象持有强引用。换句话说，window属性持有指向UIWindow对象的指针，扮演着UIWindow对象拥有者的角色。只要window属性的值不改变，UIWindow对象便始终存活。对viewController属性和MainViewController对象来说也是这样。</p>

<h2>AppDelegate.m</h2>

<p>在AppDelegate.m中，创建window和view controller对象的代码有改动，同时dealloc方法被完全删除了：</p>

<p><img src="/images/2012/08/Review-Changes-AppDelegate-source.png"></p>

<p>注意这两行代码之间的区别：</p>

<pre><code>self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen]
  bounds]] autorelease];
</code></pre>

<p>和</p>

<pre><code>self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen]
  bounds]];
</code></pre>

<p>这是正确的，autorelease不再需要了。如下创建view controller的代码也是这样：</p>

<pre><code>self.viewController = [[[MainViewController alloc] initWithNibName:
  @"MainViewController" bundle:nil] autorelease];
</code></pre>

<p>变成了</p>

<pre><code>self.viewController = [[MainViewController alloc] initWithNibName:
  @"MainViewController" bundle:nil];
</code></pre>

<p>在用ARC之前，如果你写出如下的代码，而你的属性又是&#8221;retain&#8221;的话，你将造成内存泄露：</p>

<pre><code>self.someProperty = [[SomeClass alloc] init];
</code></pre>

<p>init方法返回了一个retain过的对象，把这个对象放进了属性中，这个属性又会将这个对象retain一次。这就是你必须使用autorelease的原因，来平衡init方法引起的retain数。但在ARC下以上代码没问题，编译器足够聪明，知道不应该在这里retain两次。（译者注：作者这一段有问题。不一定非要用autorelease吧，非ARC模式下，dealloc、viewDidUnload中都可以释放）</p>

<p>我喜欢ARC的原因之一是大多数情况下完全没必要写dealloc方法。当一个对象被回收了，它的实例变量和已合成属性自动释放了，你不再需要这样写：</p>

<pre><code>- (void)dealloc
{
    [_window release];
    [_viewController release];
    [super dealloc];
}
</code></pre>

<p>因为Objective-C现在能自动处理这种情况了。实际上，甚至已经不可能写出以上代码了。在ARC模式下你不允许调用release和[super dealloc]。你仍然可以实现dealloc——过会儿会看到例子——但不再需要手动去释放那些变量了。</p>

<p>转换工具不会帮你把AppDelegate的父类从NSObject变为UIResponder。当你用Xcode的某个模板创建应用的时候，AppDelegate类成了UIResponder类的子类。父类是NSObject也没什么不好，但只要你愿意你可以把它换成UIResponder类：</p>

<pre><code>@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;
</code></pre>

<h2>Main.m</h2>

<p>在使用手动管理内存的应用中，[autorelease]方法和“自动释放池”关系紧密，后者是由NSAutoreleasePool对象来表示。每个main.m文件都有一个自动释放池，如果你直接操纵过线程的话，你肯定会为每个线程创建你自己的NSAutoreleasePool。有时开发者为了保证在循环中创建的自动释放对象不至于占太多内存，时不时需要释放掉一些，他们也会在那些做很多处理的循环内部放入NSAutoreleasePools。</p>

<p>Autorelease和ARC并不兼容，即使你没有直接在对象上调用过[autorelease]方法。每当你从一个不以alloc, int, copy, mutableCopy或new开头的方法得到返回对象的时候，ARC编译器都把为你它们自动释放掉。这些对象仍然会进入自动释放池。跟以前有很大区别的是，NSAutoreleasePool被一种新的语言指令所替代了——@autoreleasepool。</p>

<p><img src="/images/2012/08/Review-Changes-main.png"></p>

<p>转换工具把main()方法从原先的：</p>

<pre><code>&lt;a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/"&gt;NSAutoreleasePool&lt;/a&gt;* pool = [[&lt;a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/"&gt;NSAutoreleasePool&lt;/a&gt;alloc] init];
int retVal = UIApplicationMain(argc, argv, nil,
  NSStringFromClass([AppDelegate class]));
[pool release];
return retVal;
</code></pre>

<p>变成了：</p>

<pre><code>@autoreleasepool {
  int retVal = UIApplicationMain(argc, argv, nil,
    NSStringFromClass([AppDelegate class]));
    return retVal;
}
</code></pre>

<p>不仅对程序员来说可读性增强了，而且在背后也做了很多改动，使得这些新的自动释放池比以前更快了。你几乎不需要在ARC模式下考虑autorelease，除了如果你在原先的代码中使用了NSAutoreleasePool，你需要将他们换成@autoreleasepool block。自动转换工具会帮你完成的。</p>

<h2>SoundEffect.m</h2>

<p>该文件没有改动很多，仅仅去掉了 [super dealloc]。在dealloc方法中不能再调用super了。</p>

<p><img src="/images/2012/08/Review-Changes-SoundEffect.png"></p>

<p>注意dealloc方法在这仍然是需要的。在大多数你的类中可以忽略掉dealloc方法，让编译器来帮你考虑。然而有时，你需要手动释放一些资源。这里就是个例子。随着SoundEffect对象被回收，我们还需要调用AudioServicesDisposeSystemSoundID()方法来清理声音对象，dealloc最适合做这个工作。</p>

<h2>SVProgressHUD.m</h2>

<p>这个文件的改动最大，但是都很琐碎。</p>

<p><img src="/images/2012/08/Review-Changes-SVProgressHUD.png"></p>

<p>在SVProgressHUD.m顶部你能看到所谓的“类扩展”，@interface SVProgressHUD ()，其中有一些属性声明。如果你对类扩展不熟悉，（我告诉你们），它们就像分类，但是它们有其特殊的能力。类扩展的生命看起来跟分类很像，但在括号()中间没有名字。类扩展可以拥有属性和实例变量（分类有时则不行），但是你只能在.m文件中使用它们。（换句话说，你不能在别人的类中使用自己类中的类扩展。）</p>

<p>类扩展的好处在于它们允许你给你的类加上私有属性及方法名。你如果不想在你的公共接口中暴露某些属性或方法，你可以将她们放入类扩展中。SVProgressHUD的作者也是这么做的。</p>

<pre><code>@interface SVProgressHUD ()

...
@property (nonatomic, strong) &lt;a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/"&gt;NSTimer&lt;/a&gt; *fadeOutTimer;
@property (nonatomic, strong) UILabel *stringLabel;
@property (nonatomic, strong) UIImageView *imageView;
@property (nonatomic, strong) UIActivityIndicatorView *spinnerView;
...

@end
</code></pre>

<p>跟我们之前看到的一样，retain属性将变成strong属性。如果你在预览窗口滚动下，你会看到其他所有的改动都是把retain和release语句去掉了而已。</p>

<h2>真正开始转换</h2>

<p>当你对转换工具所做的改动满意时，按下Save按钮来启动。Xcode首先询问你是否需要在改动文件之前保存快照：</p>

<p><img src="/images/2012/08/Snapshots.png"></p>

<p>你可以在这里选择Enable。如果你还需要以前的代码，你可以在Projects里的Organizer窗口中找到快照。</p>

<p>在ARC转换工具结束后，按下Cmd+B来构建程序。构建应该能成功，但是SVProgressHUD.m中会有一些新的警告： 
<img src="/images/2012/08/Expression-result-unused-warning.png"></p>

<p>再次注意，这个类里仍然使用了dealloc方法，在这里是为了停止定时器，并且从NSNotificationCenter注销订阅通知。很明显，这些不是ARC会为你做的。</p>

<p>带警告的那行代码以前是这样的：</p>

<pre><code>if(fadeOutTimer != nil)
    [fadeOutTimer invalidate], [fadeOutTimer release], fadeOutTimer = nil;
</code></pre>

<p>现在是这样：</p>

<pre><code>if(fadeOutTimer != nil)
    [fadeOutTimer invalidate], fadeOutTimer, fadeOutTimer = nil;
</code></pre>

<p>工具删除了对[release]的调用，但把变量留在了那里。单单一个变量没什么用。这似乎是自动化转换工具所没有预见到的。</p>

<p>如果你对逗号表示困惑，那么你得知道在Objective-C中它是用来将多个表达式合并为一个语句的一种方式。上面的技巧是释放对象且将变量设为nil的习惯用法。因为所有都发生在一个语句中，所以if不需要大括号。</p>

<p>要消除警告，你可以将这几行代码改成：</p>

<pre><code>if(fadeOutTimer != nil)
    [fadeOutTimer invalidate], fadeOutTimer = nil;
</code></pre>

<p>Technically speaking we don’t need to do fadeOutTimer = nil; in dealloc, because the object will automatically release any instance variables when it gets deleted. In the other methods where the timer is invalidated, however, you definitely should set fadeOutTimer to nil. If you don’t, the SVProgressHUD keeps hanging on to the invalidated NSTimer object longer than it’s supposed to.</p>

<p>Build the app again and now there should be no warnings. Conversion complete!</p>

<p>But wait a minute… we skipped MainViewController and AFHTTPRequestOperation when we did the conversion. How come they suddenly compile without problems? When we tried building the project with ARC enabled earlier there were certainly plenty of errors in those files.</p>

<p>The answer is simple: the conversion tool has disabled ARC for these two source files. You can see that in the Build Phases tab on the Project Settings screen:</p>

<p>严格意义上来说，我们在dealloc中不需要让fadeOutTimer = nil; ，因为对象在被回收时会自动释放所有实例变量。在其他方法中，当定时器失效时，你必须得把fadeOutTimer设置为nil。否则，SVProgressHUD会在已失效的NSTimer上等待比预期更多的时间。</p>

<p>再次构建应用，这次应该没有警告了。转换完成！</p>

<p>但是稍等片刻&hellip; 我们在转换时跳过了MainViewController和AFHTTPRequestOperation。为什么他们会突然没任何问题就编译通过了呢？当我们之前试图在ARC模式下构建项目时，这两个文件里还有相当数量的错误的。</p>

<p>答案很简单：转换工具对这两个文件禁用了ARC。你可以在Project Settings界面的Build Phases选项卡中看到：</p>

<p><img src="/images/2012/08/ARC-disabled-per-file1.png"></p>

<p>当我们把Build Settings下面的Objective-C Automatic Reference Counting setting设为Yes的时候，我们在项目范围内启用了ARC。但你可以用-fno-objc-arc符号告诉编译器来对特定的文件忽略ARC。Xcode会在非ARC模式下编译这些文件。</p>

<p>因为指望开发者一次性将整个项目转成ARC并不合理，苹果的工作人员便使得ARC和非ARC代码可以在同一个项目中共存。小贴士：有一个简单的方法，单单用转换工具转换那些你想要迁移的文件，而让转换工具为剩下的文件自动加上 -fno-objc-arc符号。你也可以自己手动来加这个符号，但当你有很多不想ARC化的文件时你肯定会抓狂的。</p>

<h2>转换过程中的困难</h2>

<p>我们的转换过程很流畅。我们只需要在SoundEffect.m中做一个简单的改动（插入__bridge），工具会完成剩下的工作。</p>

<p>然而，LLVM3.0编译器在ARC模式下比以前的编译器更严格，因而你有可能会在预检查的时候遇到一些额外的问题。在工具接管前你可能需要改更多的地方。</p>

<p>这儿有一份简单参考，列出你可能遇到的一些问题，以及一些解决办法：</p>

<p><strong>“Cast … requires a bridged cast”</strong></p>

<p>这个我们之前看到过。当编译器自己不知道如何做转换时，它期望你能插入<strong>bridge描述符。还有两种桥接类型， </strong>bridge_transfer和__bridge_retained，用哪一个取决于你想做什么。更多信息请查询Toll-Free Bridging段落。</p>

<p><strong>“Receiver type ‘X’ for instance message is a forward declaration”</strong></p>

<p>如果你有一个类，比如说是UIView的子类MyView，然后你调用它的一个方法，或者使用它的属性，那么你需要#import该类的定义。通常这是使得你的代码顺利通过编译首先要做的，但也不总是这样。</p>

<p>举个例子，你在你的.h文件中加一个前向声明来声明MyView是一个类：</p>

<pre><code>@class MyView;
</code></pre>

<p>然后在.m文件中我们这样做：</p>

<pre><code>[myView setNeedsDisplay];
</code></pre>

<p>在以前这种做法是能够通过编译且工作良好的，可以没有#import语句。在ARC模式下你总是需要显式地加上import：</p>

<pre><code>#import "MyView.h"
</code></pre>

<p><strong>“Switch case is in protected scope”</strong></p>

<p>如果你的代码如下所示，那么你会得到这个错误：</p>

<pre><code>switch (X)
{
    case Y:
        &lt;a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/"&gt;NSString&lt;/a&gt; *s = ...;
        break;
}
</code></pre>

<p>这种方法已经行不通了。如果你要在一个case语句中声明新的指针变量，你必须把整块都放入大括号中：</p>

<pre><code>switch (X)
{
    case Y:
    {
        &lt;a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/"&gt;NSString&lt;/a&gt; *s = ...;
        break;
    }
}
</code></pre>

<p>现在变量的生命范围就明了了，ARC需要知道此信息，因为它要在合适的时间释放对象。</p>

<p><strong>“A name is referenced outside the NSAutoreleasePool scope that it was declared in”</strong></p>

<p>你肯定会有一些代码会创建自己的自动释放池：</p>

<pre><code>NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];

// . . . do calculations . . .

NSArray* sortedResults =
  [[filteredResults sortedArrayUsingSelector:@selector(compare:)]
    retain];

[pool release];
return [sortedResults autorelease];
</code></pre>

<p>转换工具需要把它们转成这样：</p>

<pre><code>@autoreleasepool
{
  // . . . do calculations . . .
  NSArray* sortedResults = [filteredResults sortedArrayUsingSelector:@
    selector(compare:)];
}
return sortedResults;
</code></pre>

<p>但这段代码不再有效。sortedResults变量在@autoreleasepool范围内声明，因而在作用域外不可访问。为修复这个问题得把变量的声明移到NSAutoreleasePool创建之前：</p>

<pre><code>&lt;a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/"&gt;NSArray&lt;/a&gt;* sortedResults;
&lt;a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/"&gt;NSAutoreleasePool&lt;/a&gt;* pool = [[&lt;a href="http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/"&gt;NSAutoreleasePool&lt;/a&gt; alloc] init];
. . .
</code></pre>

<p>现在转换工具可以正确地覆盖你代码了。</p>

<p><strong>“ARC forbids Objective-C objects in structs or unions”</strong></p>

<p>ARC的限制之一是你不能再将Objective-C对象放在C的结构体中了。以下代码不再有效：</p>

<pre><code>typedef struct
{
    UIImage *selectedImage;
    UIImage *disabledImage;
}
ButtonImages;
</code></pre>

<p>推荐做法是用Objective-C类来替代这样的结构体。我们一会儿再谈这个，到时还会介绍一些解决办法。</p>

<p>还会有一些预检查错误，但这几个是最常见的。</p>

<p>注意：如果你使用自动化转换工具一次以上，你会发现它有点古怪。如果你跟我们之前那样没有选中所有文件来转换的话，下次你想转换剩下来那些文件时，转换工具貌似什么都不会做。我的建议是你运行这个工具一次就好，不好分批去转换你的文件。</p>

<h2>接下来怎么办</h2>

<p>继续完成<a href="http://www.raywenderlich.com/5773/beginning-arc-in-ios-5-tutorial-part-2">本系列的第二部分</a>，我们会如何手动将文件转换成ARC，ARC和Core Foundation的关系，弱属性，等等更多的内容！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/04/06/windows-phone-7-e68ea8e98081e58a9fe883bde79a84e5ae9ee78eb0/">Windows Phone 7 推送功能的实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-04-06T15:30:46+08:00" pubdate data-updated="true">Apr 6<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近负责了某移动互联网产品wp7平台的推送模块，在这分享一些关于客户端推送的经验。</p>

<p>我们需要实现的是服务端能根据用户id向客户端推送私信、评论、好友请求、以及基于地理位置的一些信息。</p>

<h2>wp7与iOS push的不同</h2>

<h2> </h2>

<p>搞过symbian的push，也了解过iOS和android的相关内容，wp7的push和iOS的大致类似，也有一些不同，结合我网产品，主要在下面几个方面，也是没搞过wp7 push的我网服务端需要知道的：</p>

<p>1. <strong>Push</strong><strong>类型不同</strong></p>

<p>wp7有三种类型的push：
Toast：程序前后台都能收到，后台时弹出系统toast框，前台时程序自定义处理方式，push数据为xml格式
Raw：push数据为任意格式(json,xml等等)，但程序仅在前台时能收到，不满足我网客户端需求，本文不考虑这种类型
Tile：在客户端桌面的大图标上显示push（图片，文字等），xml格式数据，本期客户端暂时不需要
因此，暂时只需要考虑Toast类型的push。</p>

<p>2. <strong>客户端token</strong><strong>与userid</strong><strong>之间的对应</strong></p>

<p>wp7在建立push初期，检查客户端是否存在push通道。若不存在，先创建新通道，向微软MPNS（Microsoft Push Notification Service）索取到一个通道URI（这个URI我网push服务要用），并向我网push服务进行注册。若已存在，询问微软MPNS是否需要更新通道URI，同时使用已保存的通道URI向我网push服务进行注册。若MPNS反馈了新的URI，客户端需要向我网push服务更新注册信息。
注册方式有以下几种方案吧：
a) 用户登陆以后，将userid, URI, device id一起发给服务端作对应
b) 不管用户登陆与否，先将URI和device id发给服务端，因为用户手动登陆时总会上传device id给服务端，这样也能做好三者的对应
c) 通过某个固定的现有接口将device id和userid上传</p>

<p>3. <strong>Push</strong><strong>发送的格式</strong></p>

<p>wp7的toast push只支持xml格式的数据，eg:
&lt;wp:Notification xmlns:wp=&ldquo;WPNotification&rdquo;>
&lt;wp:Toast>
&lt;wp:Text1>push消息标题&lt;/wp:Text1>
&lt;wp:Text2>push消息内容&lt;/wp:Text2>
&lt;wp:Param>一些参数键值对&lt;/wp:Param>
&lt;/wp:Toast>
&lt;/wp:Notification>
其中&lt;wp:Param>中的内容可以用来传参数，eg:
&lt;wp:Param>?pushType=10&amp;poiId=20&amp;specialId=15&lt;/wp:Param>
其中，<Param> tag中的内容不能超过256个字符
服务端还要设置一些HTTP头和push参数等，可以参考：
<a href="http://msdn.microsoft.com/en-us/library/hh202945(v=vs.92">http://msdn.microsoft.com/en-us/library/hh202945(v=vs.92).aspx</a>.aspx)
<a href="http://www.daveamenta.com/2010-11/send-push-notifications-to-windows-phone-7-from-php/">http://www.daveamenta.com/2010-11/send-push-notifications-to-windows-phone-7-from-php/</a></p>

<h2>wp7与Symbian push的不同</h2>

<h2> </h2>

<p>Symbian上的push不是真正意义上的push，是使用了后台长连接的方式来实现的伪push。
这样做的缺点有：</p>

<ol>
<li><p> 费电费流量。后台始终保持着socket连接，每隔几分钟发个心跳包。</p></li>
<li><p> 从用户开机到用户打开程序这段时间内是接收不到push的，因为后台进程压根不会启动</p></li>
<li><p> 有很小的几率能造成主程序刷不出数据。这种状况出现过两三次，以至于有次发版前只能把push先咔掉。原因可能和接入点有关。</p></li>
<li><p> 实现复杂度高
1） 系统原生不支持push，push提示的UI还得自己做。一个应用得有三个进程：主进程，后台进程，push提示进程
2） 复杂的进程间通讯，主进程&mdash;&ndash;>后台进程，后台进程&lt;&mdash;&ndash;>push提示进程，不同的通讯机制（和带UI的程序通讯，以及和Console程序通讯）
3） 额外的数据结构，用队列缓存push，进程间传递的字符串的解析等</p></li>
</ol>


<p>总而言之，在Symbian上做push的感觉就是——女屌丝非要穿上黑丝齐B小短裙把自己打扮得像女神，虽然能用，但体验不会好。</p>

<h2>wp7 push的服务端</h2>

<h2> </h2>

<p>这里以发私信为例，为了能向某用户发私信push，需要保存有user id，wp7手机device id(唯一标示了一部手机)和URI三者的对应关系。通过user id找到该用户最近使用的device id，再通过device id找到与其一一对应的URI，向该URI发送一堆数据，然后由微软发给指定的客户端。</p>

<p>那么，这一堆数据是怎样的？见官方文档。<a href="http://msdn.microsoft.com/en-us/library/hh202945">http://msdn.microsoft.com/en-us/library/hh202945</a>(v=vs.92).aspx
有一些需要注意的地方：</p>

<ol>
<li></li>
</ol>


<p>Character
XML encoding</p>

<p>&lt;</p>

<p>&lt;</p>

<blockquote></blockquote>

<p>&gt;</p>

<p>&amp;</p>

<p>&amp;</p>

<p>‘</p>

<p>&apos;</p>

<p>“</p>

<p>&quot;</p>

<p>上面这些特殊字符需要转换</p>

<ol>
<li><p> &lt;wp:Param>中的内容不能超过256个字符</p></li>
<li><p> 对中文需要转换：转成utf-8后再包一层，比如：“我”转成“&#x6211;”</p></li>
<li><p> &lt;wp:Text1>和&lt;wp:Text2>，其中Text1和Text2不是用户可以随便修改的，Text1表示push Toast的标题，Text2表示内容。我原以为可以随便修改，把Text1命名为Title，Text2命名为Content，结果客户端怎么也收不到。Text1和Text2至少要存在一个，不然客户端收不到</p></li>
<li><p> &lt;wp:Param>中有三种传参数方式：
1）/page1.xaml    点击Toast后跳到客户端的page1.xmal页面
2）/page1.xaml?value1=1234 &amp;value2=9876    点击Toast后跳到客户端的page1.xmal页面，并把value1和value2传给页面
3）?value1=1234 &amp;value2=9876   点击Toast后跳到客户端的默认首页
我网用的第三种，毕竟让服务端写死客户端的跳转页面不灵活且增加沟通成本，不如跳到默认首页，在其中进行统一跳转处理</p></li>
</ol>


<p>.net服务端比php会简单一些，至少中文处理要简单些。</p>

<h2>wp7 push的客户端</h2>

<h2> </h2>

<h4> Step 1. 打开通道</h4>

<p> 首先需要打开HttpNotificationChannel，得到URI，发送push。</p>

<pre><code>        private void RegisterDevice()
        {
            App app = Application.Current as App;
            app.httpChannel = HttpNotificationChannel.Find(App.channelName);

            if (app.httpChannel != null)
            {
                SubscribeToChannelEvents();
                SubscribeToService();
                SET_COOKIE("channelUri", app.httpChannel.ChannelUri.ToString());
            }
            else
            {
                //Create new channel
                app.httpChannel = new HttpNotificationChannel(App.channelName);
                SubscribeToChannelEvents();
                app.httpChannel.Open();
                app.httpChannel.BindToShellToast();
            }
        }
</code></pre>

<p>先尝试寻找是否有已存在的通道。如果有，表示已经拥有了该设备的URI，可以直接向我网的服务器进行注册；如果没有，创建新的通道，设置事件处理函数，尝试打开通道，此时程序会向MPNS索取URI  </p>

<h4>Step 2. 设置事件处理函数</h4>

<pre><code>        private void SubscribeToChannelEvents()
        {
            App app = Application.Current as App;
            //Register to UriUpdated event - occurs when channel successfully opens
            app.httpChannel.ChannelUriUpdated += new EventHandler&lt;NotificationChannelUriEventArgs&gt;(httpChannel_ChannelUriUpdated);

            //Subscribe to Toast Notifications
            app.httpChannel.ShellToastNotificationReceived += new EventHandler&lt;NotificationEventArgs&gt;(httpChannel_ShellToastNotificationReceived);

            //general error handling for push channel
            app.httpChannel.ErrorOccurred += new EventHandler&lt;NotificationChannelErrorEventArgs&gt;(httpChannel_ExceptionOccurred);

        }
</code></pre>

<p> 订阅Toast push这句目的是为了能让程序在前台收到Push时自定义处理，如果值需要后台接收Push，则不需要这句。</p>

<pre><code>        void httpChannel_ChannelUriUpdated(object sender, NotificationChannelUriEventArgs e)
        {
            App app = Application.Current as App;
            // Optionally save the URI locally here - e.ChannelUri.ToString();
            string newChannelUri = e.ChannelUri.ToString();
            string oldChannelUri = GET_COOKIE("channelUri") as string;
            if (newChannelUri.CompareTo(oldChannelUri)!=0)
            {
                SET_COOKIE("channelUri", e.ChannelUri.ToString());
                Dispatcher.BeginInvoke(() =&gt;
                {
                    SubscribeToService();
                });
            }
        }

        void httpChannel_ExceptionOccurred(object sender, NotificationChannelErrorEventArgs e)
        {
            // Handle notification exceptions here
        }

        void httpChannel_ShellToastNotificationReceived(object sender, NotificationEventArgs e)
        {
            // This runs when a toast notification is received while the app is running
            if (e.Collection != null)
            {
                Dictionary&lt;string, string&gt; collection = (Dictionary&lt;string, string&gt;)e.Collection;
                Dispatcher.BeginInvoke(() =&gt;
                {
                    //MessageBox.Show(collection["wp:Text2"], collection["wp:Text1"], MessageBoxButton.OK);
                });
            }
        }
</code></pre>

<p>httpChannel_ShellToastNotificationReceived函数不在UI线程中，需要访问UI线程的MessageBox的话需要用Dispatcher.BeginInvoke。
httpChannel_ChannelUriUpdated函数在MPNS返回最新URI时被调用，这里优先使用本地缓存的URI，防止重复注册URI（一般不会，只是做保护处理）。
SubscribeToService中只是简单地调用了客户端现存的一个接口，将device id和URI上传到服务端，服务端此时已经能做好device id，userid, URI的对应了。这个接口由于加上了URI，所以会比较长，因此少调为妙。
此时可以telnet db3.notify.live.net 80，post一些数据给微软，顺利的话应该能在客户端接收到push：</p>

<p> <img src="/images/2012/04/1.png"></p>

<h4>Step 3. 处理push跳转</h4>

<p>不同的push类型需要跳到客户端的不同页面，在默认首页中增加跳转逻辑，需要和各页面负责人进行沟通，就不详述了。</p>

<h2>用后台代理模仿心跳包</h2>

<h2> </h2>

<p> 以上的做法能够满足大部分的推送需求，但是对于一些基于地理位置的推送服务，服务端需要知道客户端的实时经纬度（尽可能做到实时），然后根据用户的当前经纬度判断是否触发推送。因此，客户端需要尽可能实时的将userid和经纬度传给服务端。这在symbian使用心跳包建立push的情况下很容易做到，在心跳包上加上相应字段即可，但是wp7对后台程序的限制很严格，之前也考虑过不走微软的mpns网络，用后台长连接的方式做push，这样服务端不需要做改动，但经过一些调研，发现不可行，原因如下：</p>

<p>wp7的7.0版本不支持后台运行，只能用mpns做push。 
7.1版本会支持Background Agents，但有很多限制（<a href="http://msdn.microsoft.com/en-us/library/hh202944(v=vs.92">http://msdn.microsoft.com/en-us/library/hh202944(v=vs.92).aspx</a>.aspx)）：
1.  后台任务有很多API限制
2.  省电模式下后台代理无法运行，也就无法push
3.  一部手机能开的后台代理数有限制，最少可能只有6个，如果超过限制会引起异常
4.  每30分钟运行一次，期间http长连接能否保持是问题
总的来说，wp7为了省电省流量，对开发者自己的后台任务做了很多限制，体验和实现难度来讲也是用原生的push notification更好一些。</p>

<p>push没法用后台代理来实现，但是一些对不需要严格实时（30分钟一次可以接受）的任务，如上报user id和经纬度，可以使用后台代理实现。可参考：<a href="http://msdn.microsoft.com/en-us/library/hh202961(v=vs.92">http://msdn.microsoft.com/en-us/library/hh202961(v=vs.92).aspx</a>.aspx)</p>

<h4>Step 1. 主程序中开启后台代理</h4>

<pre><code>protected void StartBackAgent()
        {
            // Obtain a reference to the period task, if one exists
            periodicTask = ScheduledActionService.Find(periodicTaskName) as PeriodicTask;

            // If the task already exists and background agents are enabled for the
            // application, you must remove the task and then add it again to update
            // the schedule
            if (periodicTask != null)
            {
                RemoveAgent(periodicTaskName);
            }

            periodicTask = new PeriodicTask(periodicTaskName);

            // The description is required for periodic agents. This is the string that the user
            // will see in the background services Settings page on the device.
            periodicTask.Description = "This is Our Background Agent";

            // Place the call to Add in a try block in case the user has disabled agents
            try
            {
                ScheduledActionService.Add(periodicTask);

                // If debugging is enabled, use LaunchForTest to launch the agent in one minute.
                ScheduledActionService.LaunchForTest(periodicTaskName, TimeSpan.FromSeconds(5));
            }
            catch (InvalidOperationException exception)
            {
                if (exception.Message.Contains("BNS Error: The action is disabled"))
                {
                    //MessageBox.Show("Background agents for this application have been disabled by the user.");
                }
                if (exception.Message.Contains("BNS Error: The maximum number of ScheduledActions of this type have already been added."))
                {
                    // No user action required. The system prompts the user when the hard limit of periodic tasks has been reached.
                }
            }
            catch (SchedulerServiceException)
            {
                // No user action required.
            }
        }
</code></pre>

<p>参考了微软给的示例代码，当然也可以关闭代理：</p>

<pre><code>        protected void EndBackAgent()
        {
            periodicTask = ScheduledActionService.Find(periodicTaskName) as PeriodicTask;
            if (periodicTask != null)
            {
                RemoveAgent(periodicTaskName);
            }
        }
</code></pre>

<p>LaunchForTest是方便调试使用的，加上try catch是为了防止用户设置了关闭后台代理后引发异常。</p>

<h4>Step 2. 在ScheduledTaskAgent中获取GPS</h4>

<pre><code>       protected override void OnInvoke(ScheduledTask task)
        {
            //TODO: 添加用于在后台执行任务的代码
         taskName = task.Name;
            GetGPS();
        }

        private void GetGPS()
        {
            if (!SystemCore.Instance.position().IsNaN)
            {
                SendGPSByHttpWebRequest();
            }
            else
            {
                gps_timecount = 0;
                gps_timer = new Timer(new TimerCallback(gps_timer_Tick),null,0,1000);
            }
        }

        void gps_timer_Tick(object sender)
        {
            gps_timecount++;
            gps_timer.Dispose();
            gps_timer = null;
            if (!SystemCore.Instance.position().IsNaN)
            {
                SendGPSByHttpWebRequest();
            }
            else if (gps_timecount &lt; 10)
            {
                gps_timer = new Timer(new TimerCallback(gps_timer_Tick), null, 0, 1000);
            }
        }
</code></pre>

<p>增加了限时处理，超过10秒未取到GPS则放弃此次上传。用Timer而未使用DispatcherTimer的原因是，使用后者必须用BeginInvoke的方式在Dispatcher线程中创建，不然会crash，而在Dispatcher线程中用HttpWebRequest发起http请求没有成功，可能是死锁等原因，暂时没走通这条路，就换了Timer，这样能在后台代理线程中发http。</p>

<h4>Step 3. 使用独立存储+Mutex从主程序获取user id</h4>

<p>wp7中是没有IPC的，或者说不允许用户创建的程序间进行通信，可以使用独立存储或者IsolatedStorageSettings或者LINQ 2 SQL在主程序和后台代理间进行通信，我只用了独立存储，连Mutex也没加，一是主程序写，代理读，二是程序逻辑不太可能造成冲突。官方不推荐使用IsolatedStorageSettings。</p>

<h4>Step 4. 在ScheduledTaskAgent中使用HttpWebRequest</h4>

<p>数据都准备好了(user id+经纬度)，接下来就是发http了。最开始是按照下面链接中的方法，没有发成功，不过还是有些收获。<a href="http://www.cnblogs.com/yanxiaodi/archive/2012/01/18/2325320.html">http://www.cnblogs.com/yanxiaodi/archive/2012/01/18/2325320.html</a>  然后在网上搜了一圈都试过，没有能成功的。最后找到了一个老外的分享，twitter客户端的push机制，用了里面的一个库，成功了。<a href="http://blogs.msdn.com/b/ptorr/archive/2011/07/12/background-agents-part-2-of-3.aspx">http://blogs.msdn.com/b/ptorr/archive/2011/07/12/background-agents-part-2-of-3.aspx</a> 
在http成功发送后得调用NotifyComplete通知操作系统这次任务圆满完成，期待下次继续，不调用的话下次时间片到了不会启动后台代理。在网络请求很长时间不返回的情况下，如果这时间超过了系统能允许后台代理一次运行的时间（25秒），那么就不会调用到NotifyComplete，导致下次无法启动，因此这里有必要加上限时处理。</p>

<h2>push的统计</h2>

<h2> </h2>

<p>在Symbian上曾做过push统计的事情，push功能推出去需要知道用户的反馈：收到过多少push，分别是什么类型的，用户打开过多少次push，每次分别是什么类型的等等。最方便的做法就是讲统计数据加到心跳包末尾：
在心跳包URL末尾加a=<strong>来统计push。
a=0            默认情况
a=1            客户端在前台时候收到push
a=2            客户端在后台时候收到push
a=3            用户确定
a=4            用户取消
当a=1,2,3,4时，为了统计push类型，在数字后直接跟push类型（0,1,2,…15,16等），不足两位补足两位。如a=101, a=313,a=416等
ps：
Symbian V5用a=</strong>
Symbian V3用b=<strong>
iOS用c=</strong>
安卓目前没有需求，若有就用d=**
iOS由于使用了长连接+APNS结合的两种push方式，所以也能够用这种方法统计一部分数据。
wp7目前没有统计需求，有的话再调研下。</p>

<p> </p>

<p>最后感谢msdn，google和Stackoverflow。
还不小心发现一枚山寨版Stackoverflow(栈溢出)，叫Segmentfault(段错误) 。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/6/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/4/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/ios/'>iOS (26)</a></li>
<li class='category'><a href='/blog/categories/symbian/'>symbian (5)</a></li>
<li class='category'><a href='/blog/categories/si-wei/'>思维 (1)</a></li>
<li class='category'><a href='/blog/categories/ji-zhu/'>技术 (6)</a></li>
<li class='category'><a href='/blog/categories/sheng-huo/'>生活 (17)</a></li>
<li class='category'><a href='/blog/categories/fan-yi/'>翻译 (19)</a></li>
<li class='category'><a href='/blog/categories/zhuan-zai/'>转载 (2)</a></li>

  </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/04/18/have-fun-with-runtime%E5%89%AF%E6%9C%AC/">给第三方库打patch</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/18/have-fun-with-runtime/">给第三方库打patch</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/08/simple-usage-of-photoshop-as-an-ios-developer/">Basic Designer Skills</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/28/writing-octopress-blog-on-a-second-machine/">Writing Octopress Blog on a Second Machine</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/25/ios-e5bc80e58f91e88085e5bf85e79fa5e79a84-75-e4b8aae5b7a5e585b7efbc88e8af91e69687efbc89/">iOS 开发者必知的 75 个工具（译文）</a>
      </li>
    
  </ul>
</section>
<section>
<h1>Rencent Comments</h1>
<ul class="ds-recent-comments" data-num-items="10">
</ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"njuxjy"};
(function() {
var ds = document.createElement('script');
ds.type = 'text/javascript';
ds.async = true;ds.src = 'http://static.duoshuo.com/embed.js';
ds.charset = 'UTF-8';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - njuxjy -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  










<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F1d61f50236b206efa5ccce7e436f3bbb' type='text/javascript'%3E%3C/script%3E"));
</script>

</body>
</html>
